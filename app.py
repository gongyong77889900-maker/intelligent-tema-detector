import streamlit as st
import pandas as pd
import numpy as np
import re
import logging
from typing import Dict, List, Set, Tuple, Any
import itertools
from collections import defaultdict
import time
from io import BytesIO
from functools import lru_cache

# ËÆæÁΩÆÈ°µÈù¢
st.set_page_config(
    page_title="ÂΩ©Á•®ÂÆåÁæéË¶ÜÁõñÂàÜÊûêÁ≥ªÁªü",
    page_icon="üéØ",
    layout="wide"
)

# ==================== ÈÖçÁΩÆÂ∏∏Èáè ====================
COVERAGE_CONFIG = {
    'min_number_count': {
        'six_mark': 11,  # ÂÖ≠ÂêàÂΩ©
        '10_number': 3,   # 10‰∏™Âè∑Á†ÅÁöÑÂΩ©Áßç
        'fast_three': 3,  # Âø´‰∏âÂíåÂÄº
    },
    'min_avg_amount': {
        'six_mark': 2,
        '10_number': 1,
        'fast_three': 1,
    },
    'similarity_thresholds': {
        'excellent': 90,
        'good': 80,
        'fair': 70
    },
    'target_lotteries': {
        'six_mark': [
            'Êñ∞Êæ≥Èó®ÂÖ≠ÂêàÂΩ©', 'Êæ≥Èó®ÂÖ≠ÂêàÂΩ©', 'È¶ôÊ∏ØÂÖ≠ÂêàÂΩ©', '‰∏ÄÂàÜÂÖ≠ÂêàÂΩ©',
            '‰∫îÂàÜÂÖ≠ÂêàÂΩ©', '‰∏âÂàÜÂÖ≠ÂêàÂΩ©', 'È¶ôÊ∏Ø‚ë•ÂêàÂΩ©', 'ÂàÜÂàÜÂÖ≠ÂêàÂΩ©',
            'Âè∞ÊπæÂ§ß‰πêÈÄè', 'Â§ßÂèëÂÖ≠ÂêàÂΩ©', 'Âø´‰πê6ÂêàÂΩ©',
            'Âπ∏ËøêÂÖ≠ÂêàÂΩ©', 'ÊûÅÈÄüÂÖ≠ÂêàÂΩ©', 'ËÖæËÆØÂÖ≠ÂêàÂΩ©', '‰∫îÂàÜÂΩ©ÂÖ≠Âêà',
            '‰∏âÂàÜÂΩ©ÂÖ≠Âêà', '‰∏ÄÂàÜÂΩ©ÂÖ≠Âêà', 'Âπ∏Ëøê‚ë•Âêà', 'ÊûÅÈÄü‚ë•Âêà'
        ],
        '10_number': [
            'Êó∂Êó∂ÂΩ©', 'ÈáçÂ∫ÜÊó∂Êó∂ÂΩ©', 'Êñ∞ÁñÜÊó∂Êó∂ÂΩ©', 'Â§©Ê¥•Êó∂Êó∂ÂΩ©',
            'ÂàÜÂàÜÊó∂Êó∂ÂΩ©', '‰∫îÂàÜÊó∂Êó∂ÂΩ©', '‰∏âÂàÜÊó∂Êó∂ÂΩ©', 'Âåó‰∫¨Êó∂Êó∂ÂΩ©',
            'PK10', 'Âåó‰∫¨PK10', 'PKÊãæ', 'Âπ∏ËøêPK10', 'ËµõËΩ¶', 'Â§ßÂèëËµõËΩ¶',
            'Âπ∏Ëøê28', 'Âåó‰∫¨28', 'Âä†ÊãøÂ§ß28', 'ÊûÅÈÄüPK10', 'ÂàÜÂàÜPK10', 'Â§ßÂèëÂø´‰∏â',
            'Âπ∏ËøêÈ£ûËâá', 'Êæ≥Ê¥≤Âπ∏Ëøê10', 'ÊûÅÈÄüÈ£ûËâá', 'Êæ≥Ê¥≤È£ûËâá',
            'Âåó‰∫¨ËµõËΩ¶', 'ÊûÅÈÄüËµõËΩ¶', 'Âπ∏ËøêËµõËªä', 'ÂàÜÂàÜËµõËΩ¶',
            'ËÖæËÆØÂàÜÂàÜÂΩ©', '‰∫îÂàÜÊó∂Êó∂ÂΩ©', '‰∏âÂàÜÊó∂Êó∂ÂΩ©', '‰∏ÄÂàÜÊó∂Êó∂ÂΩ©',
            'Âπ∏Ëøê5', 'Âπ∏Ëøê8', 'Âπ∏Ëøê10', 'Âπ∏Ëøê12'
        ],
        'fast_three': [
            'Âø´‰∏â', 'Âø´3', 'K3', 'ÂàÜÂàÜÂø´‰∏â', '‰∫îÂàÜÂø´‰∏â', '‰∏âÂàÜÂø´‰∏â',
            'Âåó‰∫¨Âø´‰∏â', 'Ê±üËãèÂø´‰∏â', 'ÂÆâÂæΩÂø´‰∏â', 'Â§ßÂèëÂø´‰∏â',
            'Êæ≥Ê¥≤Âø´‰∏â', 'ÂÆæÊûúÂø´‰∏â', 'Âä†Â∑ûÂø´‰∏â', 'Âπ∏ËøêÂø´‰∏â',
            'Êæ≥Èó®Âø´‰∏â', 'È¶ôÊ∏ØÂø´‰∏â', 'Âè∞ÊπæÂø´‰∏â', 'ÊûÅÈÄüÂø´‰∏â'
        ],
        '3d_series': [
            'ÊéíÂàó‰∏â', 'ÊéíÂàó3', 'Á¶èÂΩ©3D', '3D', 'ÊûÅÈÄü3D',
            'Âπ∏ËøêÊéíÂàó3', '‰∏ÄÂàÜÊéíÂàó3', '‰∏âÂàÜÊéíÂàó3', '‰∫îÂàÜÊéíÂàó3',
            'Â§ßÂèëÊéíÂàó3', 'Â•ΩËøêÊéíÂàó3', 'ÊûÅÈÄüÊéíÂàó3'
        ],
        'five_star': [
            '‰∫îÊòüÂΩ©', '‰∫îÊòüÁõ¥ÈÄâ', '‰∫îÊòüÁªÑÈÄâ', '‰∫îÊòüÈÄöÈÄâ',
            '‰∫îÊòüÂΩ©Áßç', '‰∫îÊòüÂΩ©Á•®', 'ÊûÅÈÄü‰∫îÊòü'
        ]
    }
}

# ==================== Êó•ÂøóËÆæÁΩÆ ====================
def setup_logging():
    """ËÆæÁΩÆÊó•ÂøóÁ≥ªÁªü"""
    logger = logging.getLogger('CoverageAnalysis')
    logger.setLevel(logging.INFO)
    
    if not logger.handlers:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        console_handler.setFormatter(formatter)
        
        logger.addHandler(console_handler)
    
    return logger

logger = setup_logging()

# ==================== ÂÖ®ÂΩ©ÁßçÂàÜÊûêÂô® ====================
class MultiLotteryCoverageAnalyzer:
    """ÂÖ®ÂΩ©ÁßçË¶ÜÁõñÂàÜÊûêÂô® - ÊîØÊåÅÂÖ≠ÂêàÂΩ©„ÄÅÊó∂Êó∂ÂΩ©„ÄÅPK10„ÄÅÂø´‰∏âÁ≠â"""
    
    def __init__(self):
        # ÂÆö‰πâÂêÑÂΩ©ÁßçÁöÑÂè∑Á†ÅËåÉÂõ¥
        self.lottery_configs = {
            'six_mark': {
                'number_range': set(range(1, 50)),
                'total_numbers': 49,
                'type_name': 'ÂÖ≠ÂêàÂΩ©',
                'play_keywords': ['ÁâπÁ†Å', 'ÁâπÁéõ', 'ÁâπÈ©¨', 'ÁâπÁ¢º', 'Ê≠£Á†Å', 'Ê≠£Áâπ', 'Ê≠£ËÇñ', 'Âπ≥Á†Å', 'Âπ≥Áâπ']
            },
            'six_mark_tail': {  # üÜï Êñ∞Â¢ûÔºöÂÖ≠ÂêàÂΩ©Â∞æÊï∞Áé©Ê≥ï
                'number_range': set(range(0, 10)),  # Â∞æÊï∞0-9
                'total_numbers': 10,
                'type_name': 'ÂÖ≠ÂêàÂΩ©Â∞æÊï∞',
                'play_keywords': ['Â∞æÊï∞', 'ÁâπÂ∞æ', 'ÂÖ®Â∞æ']
            },
            '10_number': {
                'number_range': set(range(1, 11)),
                'total_numbers': 10,
                'type_name': '10‰∏™Âè∑Á†ÅÂΩ©Áßç',
                'play_keywords': ['ÂÆö‰ΩçËÉÜ', '‰∏ÄÂ≠óÂÆö‰Ωç', '‰∏ÄÂ≠ó', 'ÂÆö‰Ωç', 'Â§ßÂ∞èÂçïÂèå', 'ÈæôËôé', 'ÂÜ†ÂÜõ', '‰∫öÂÜõ', 'Â≠£ÂÜõ', 'Á¨¨ÂõõÂêç', 'Á¨¨‰∫îÂêç', 'Á¨¨ÂÖ≠Âêç', 'Á¨¨‰∏ÉÂêç', 'Á¨¨ÂÖ´Âêç', 'Á¨¨‰πùÂêç', 'Á¨¨ÂçÅÂêç', 'Á¨¨‰∏ÄÂêç', 'Á¨¨‰∫åÂêç', 'Á¨¨‰∏âÂêç', 'Ââç‰∏Ä']
            },
            '10_number_sum': {  # üÜï Êñ∞Â¢ûÔºöÂÜ†‰∫öÂíåÁé©Ê≥ï
                'number_range': set(range(3, 20)),  # ÂÜ†‰∫öÂíå3-19
                'total_numbers': 17,
                'type_name': 'ÂÜ†‰∫öÂíå',
                'play_keywords': ['ÂÜ†‰∫öÂíå', 'ÂÜ†‰∫öÂíåÂÄº']
            },
            'fast_three_base': {  # üÜï Êñ∞Â¢ûÔºöÂø´‰∏âÂü∫Á°ÄÁé©Ê≥ï
                'number_range': set(range(1, 7)),  # Âü∫Á°ÄÂè∑Á†Å1-6
                'total_numbers': 6,
                'type_name': 'Âø´‰∏âÂü∫Á°Ä',
                'play_keywords': ['‰∏âÂÜõ', 'Áã¨ËÉÜ', 'ÂçïÁ†Å', '‰∫å‰∏çÂêåÂè∑', '‰∏â‰∏çÂêåÂè∑']
            },
            'fast_three_sum': {  # üÜï Êñ∞Â¢ûÔºöÂø´‰∏âÂíåÂÄºÁé©Ê≥ï
                'number_range': set(range(3, 19)),  # ÂíåÂÄºËåÉÂõ¥3-18
                'total_numbers': 16,
                'type_name': 'Âø´‰∏âÂíåÂÄº',
                'play_keywords': ['ÂíåÂÄº', 'ÁÇπÊï∞']
            },
            'ssc_3d': {  # üÜï Êñ∞Â¢ûÔºöÊó∂Êó∂ÂΩ©Âíå3DÁ≥ªÂàó
                'number_range': set(range(0, 10)),  # Âè∑Á†Å0-9
                'total_numbers': 10,
                'type_name': 'Êó∂Êó∂ÂΩ©/3D',
                'play_keywords': ['ÂÆö‰ΩçËÉÜ', 'Á¨¨1ÁêÉ', 'Á¨¨2ÁêÉ', 'Á¨¨3ÁêÉ', 'Á¨¨4ÁêÉ', 'Á¨¨5ÁêÉ', '‰∏á‰Ωç', 'ÂçÉ‰Ωç', 'Áôæ‰Ωç', 'ÂçÅ‰Ωç', '‰∏™‰Ωç']
            }
        }
        
        # ÂÆåÊï¥ÁöÑÂΩ©ÁßçÂàóË°®
        self.target_lotteries = {}
        for lottery_type, lotteries in COVERAGE_CONFIG['target_lotteries'].items():
            self.target_lotteries[lottery_type] = lotteries
        
        # Â¢ûÂº∫ÁöÑÂàóÂêçÊò†Â∞ÑÂ≠óÂÖ∏
        self.column_mappings = {
            '‰ºöÂëòË¥¶Âè∑': ['‰ºöÂëòË¥¶Âè∑', '‰ºöÂëòË¥¶Êà∑', 'Ë¥¶Âè∑', 'Ë¥¶Êà∑', 'Áî®Êà∑Ë¥¶Âè∑', 'Áé©ÂÆ∂Ë¥¶Âè∑', 'Áî®Êà∑ID', 'Áé©ÂÆ∂ID', 'Áî®Êà∑ÂêçÁß∞', 'Áé©ÂÆ∂ÂêçÁß∞'],
            'ÂΩ©Áßç': ['ÂΩ©Áßç', 'ÂΩ©Á•û', 'ÂΩ©Á•®ÁßçÁ±ª', 'Ê∏∏ÊàèÁ±ªÂûã', 'ÂΩ©Á•®Á±ªÂûã', 'Ê∏∏ÊàèÂΩ©Áßç', 'ÂΩ©Á•®ÂêçÁß∞', 'ÂΩ©Á≥ª', 'Ê∏∏ÊàèÂêçÁß∞'],
            'ÊúüÂè∑': ['ÊúüÂè∑', 'ÊúüÊï∞', 'ÊúüÊ¨°', 'Êúü', 'Â•ñÊúü', 'ÊúüÂè∑‰ø°ÊÅØ', 'ÊúüÂè∑ÁºñÂè∑', 'ÂºÄÂ•ñÊúüÂè∑', 'Â•ñÊúüÂè∑'],
            'Áé©Ê≥ï': ['Áé©Ê≥ï', 'Áé©Ê≥ïÂàÜÁ±ª', 'ÊäïÊ≥®Á±ªÂûã', 'Á±ªÂûã', 'ÊäïÊ≥®Áé©Ê≥ï', 'Áé©Ê≥ïÁ±ªÂûã', 'ÂàÜÁ±ª', 'Áé©Ê≥ïÂêçÁß∞', 'ÊäïÊ≥®ÊñπÂºè'],
            'ÂÜÖÂÆπ': ['ÂÜÖÂÆπ', 'ÊäïÊ≥®ÂÜÖÂÆπ', '‰∏ãÊ≥®ÂÜÖÂÆπ', 'Ê≥®ÂçïÂÜÖÂÆπ', 'ÊäïÊ≥®Âè∑Á†Å', 'Âè∑Á†ÅÂÜÖÂÆπ', 'ÊäïÊ≥®‰ø°ÊÅØ', 'Âè∑Á†Å', 'ÈÄâÂè∑'],
            'ÈáëÈ¢ù': ['ÈáëÈ¢ù', '‰∏ãÊ≥®ÊÄªÈ¢ù', 'ÊäïÊ≥®ÈáëÈ¢ù', 'ÊÄªÈ¢ù', '‰∏ãÊ≥®ÈáëÈ¢ù', 'ÊäïÊ≥®È¢ù', 'ÈáëÈ¢ùÊï∞ÂÄº', 'ÂçïÊ≥®ÈáëÈ¢ù', 'ÊäïÊ≥®È¢ù', 'Èí±', 'ÂÖÉ']
        }
        
        self.account_keywords = ['‰ºöÂëò', 'Ë¥¶Âè∑', 'Ë¥¶Êà∑', 'Áî®Êà∑', 'Áé©ÂÆ∂', 'id', 'name', 'user', 'player']
        
        # Áé©Ê≥ïÂàÜÁ±ªÊò†Â∞Ñ - Êâ©Â±ïÊîØÊåÅÂÖ≠ÂêàÂΩ©Ê≠£Á†ÅÊ≠£Áâπ
        self.play_mapping = {
            # ========== ÂÖ≠ÂêàÂΩ©Âè∑Á†ÅÁé©Ê≥ï ==========
            # ÁâπÁ†ÅÁõ∏ÂÖ≥
            'ÁâπÁ†Å': 'ÁâπÁ†Å',
            'ÁâπÁ†ÅA': 'ÁâπÁ†Å',
            'ÁâπÁ†ÅB': 'ÁâπÁ†Å',
            'ÁâπÁ†ÅÁêÉ': 'ÁâπÁ†Å',
            'ÁâπÁ†Å_ÁâπÁ†Å': 'ÁâπÁ†Å',
            'ÁâπÁéõ': 'ÁâπÁ†Å',
            'ÁâπÈ©¨': 'ÁâπÁ†Å',
            'ÁâπÁ¢º': 'ÁâπÁ†Å',
            
            # Ê≠£Á†ÅÁõ∏ÂÖ≥
            'Ê≠£Á†Å': 'Ê≠£Á†Å',
            'Ê≠£Á†Å‰∏Ä': 'Ê≠£Á†Å‰∏Ä',
            'Ê≠£Á†Å‰∫å': 'Ê≠£Á†Å‰∫å',
            'Ê≠£Á†Å‰∏â': 'Ê≠£Á†Å‰∏â',
            'Ê≠£Á†ÅÂõõ': 'Ê≠£Á†ÅÂõõ',
            'Ê≠£Á†Å‰∫î': 'Ê≠£Á†Å‰∫î',
            'Ê≠£Á†ÅÂÖ≠': 'Ê≠£Á†ÅÂÖ≠',
            'Ê≠£Á†Å1': 'Ê≠£Á†Å‰∏Ä',
            'Ê≠£Á†Å2': 'Ê≠£Á†Å‰∫å',
            'Ê≠£Á†Å3': 'Ê≠£Á†Å‰∏â',
            'Ê≠£Á†Å4': 'Ê≠£Á†ÅÂõõ',
            'Ê≠£Á†Å5': 'Ê≠£Á†Å‰∫î',
            'Ê≠£Á†Å6': 'Ê≠£Á†ÅÂÖ≠',
            'Ê≠£Á†Å1-6': 'Ê≠£Á†Å',
            'Ê≠£Á†Å1-6 Ê≠£Á†Å': 'Ê≠£Á†Å',
            'Ê≠£Á†Å1-6_Ê≠£Á†Å': 'Ê≠£Á†Å',
            'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∏Ä': 'Ê≠£Á†Å‰∏Ä',
            'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∫å': 'Ê≠£Á†Å‰∫å',
            'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∏â': 'Ê≠£Á†Å‰∏â',
            'Ê≠£Á†Å1-6_Ê≠£Á†ÅÂõõ': 'Ê≠£Á†ÅÂõõ',
            'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∫î': 'Ê≠£Á†Å‰∫î',
            'Ê≠£Á†Å1-6_Ê≠£Á†ÅÂÖ≠': 'Ê≠£Á†ÅÂÖ≠',
            
            # Ê≠£ÁâπÁõ∏ÂÖ≥
            'Ê≠£Áâπ': 'Ê≠£Áâπ',
            'Ê≠£ÁéõÁâπ': 'Ê≠£Áâπ',
            'Ê≠£Á†ÅÁâπ': 'Ê≠£Áâπ',
            'Ê≠£‰∏ÄÁâπ': 'Ê≠£1Áâπ',
            'Ê≠£‰∫åÁâπ': 'Ê≠£2Áâπ',
            'Ê≠£‰∏âÁâπ': 'Ê≠£3Áâπ',
            'Ê≠£ÂõõÁâπ': 'Ê≠£4Áâπ',
            'Ê≠£‰∫îÁâπ': 'Ê≠£5Áâπ',
            'Ê≠£ÂÖ≠Áâπ': 'Ê≠£6Áâπ',
            'Ê≠£1Áâπ': 'Ê≠£1Áâπ',
            'Ê≠£2Áâπ': 'Ê≠£2Áâπ',
            'Ê≠£3Áâπ': 'Ê≠£3Áâπ',
            'Ê≠£4Áâπ': 'Ê≠£4Áâπ',
            'Ê≠£5Áâπ': 'Ê≠£5Áâπ',
            'Ê≠£6Áâπ': 'Ê≠£6Áâπ',
            'Ê≠£Á†ÅÁâπ_Ê≠£‰∏ÄÁâπ': 'Ê≠£1Áâπ',
            'Ê≠£Á†ÅÁâπ_Ê≠£‰∫åÁâπ': 'Ê≠£2Áâπ',
            'Ê≠£Á†ÅÁâπ_Ê≠£‰∏âÁâπ': 'Ê≠£3Áâπ',
            'Ê≠£Á†ÅÁâπ_Ê≠£ÂõõÁâπ': 'Ê≠£4Áâπ',
            'Ê≠£Á†ÅÁâπ_Ê≠£‰∫îÁâπ': 'Ê≠£5Áâπ',
            'Ê≠£Á†ÅÁâπ_Ê≠£ÂÖ≠Áâπ': 'Ê≠£6Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∏ÄÁâπ': 'Ê≠£1Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∫åÁâπ': 'Ê≠£2Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∏âÁâπ': 'Ê≠£3Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£ÂõõÁâπ': 'Ê≠£4Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∫îÁâπ': 'Ê≠£5Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£ÂÖ≠Áâπ': 'Ê≠£6Áâπ',
            'Ê≠£ÁéõÁâπ': 'Ê≠£Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∏ÄÁâπ': 'Ê≠£1Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∫åÁâπ': 'Ê≠£2Áâπ', 
            'Ê≠£ÁéõÁâπ_Ê≠£‰∏âÁâπ': 'Ê≠£3Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£ÂõõÁâπ': 'Ê≠£4Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£‰∫îÁâπ': 'Ê≠£5Áâπ',
            'Ê≠£ÁéõÁâπ_Ê≠£ÂÖ≠Áâπ': 'Ê≠£6Áâπ',
            
            # Âπ≥Á†ÅÁõ∏ÂÖ≥
            'Âπ≥Á†Å': 'Âπ≥Á†Å',
            'Âπ≥Áâπ': 'Âπ≥Áâπ',
            
            # Â∞æÊï∞Áõ∏ÂÖ≥
            'Â∞æÊï∞': 'Â∞æÊï∞',
            'Â∞æÊï∞_Â§¥Â∞æÊï∞': 'Â∞æÊï∞_Â§¥Â∞æÊï∞',
            'ÁâπÂ∞æ': 'ÁâπÂ∞æ',
            'ÂÖ®Â∞æ': 'ÂÖ®Â∞æ',
            'Â∞æÊï∞_Ê≠£ÁâπÂ∞æÊï∞': 'Â∞æÊï∞',
            
            # ========== Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶Âè∑Á†ÅÁé©Ê≥ï ==========
            # ÂÆö‰ΩçËÉÜÁõ∏ÂÖ≥
            'ÂÆö‰ΩçËÉÜ': 'ÂÆö‰ΩçËÉÜ',
            '‰∏ÄÂ≠óÂÆö‰Ωç': 'ÂÆö‰ΩçËÉÜ',
            '‰∏ÄÂ≠ó': 'ÂÆö‰ΩçËÉÜ',
            'ÂÆö‰Ωç': 'ÂÆö‰ΩçËÉÜ',
            
            # ÂêçÊ¨°Áé©Ê≥ï
            'ÂÜ†ÂÜõ': 'ÂÜ†ÂÜõ',
            '‰∫öÂÜõ': '‰∫öÂÜõ',
            'Â≠£ÂÜõ': 'Â≠£ÂÜõ',
            'Á¨¨‰∏ÄÂêç': 'ÂÜ†ÂÜõ',
            'Á¨¨‰∫åÂêç': '‰∫öÂÜõ',
            'Á¨¨‰∏âÂêç': 'Â≠£ÂÜõ',
            'Á¨¨ÂõõÂêç': 'Á¨¨ÂõõÂêç',
            'Á¨¨‰∫îÂêç': 'Á¨¨‰∫îÂêç',
            'Á¨¨ÂÖ≠Âêç': 'Á¨¨ÂÖ≠Âêç',
            'Á¨¨‰∏ÉÂêç': 'Á¨¨‰∏ÉÂêç',
            'Á¨¨ÂÖ´Âêç': 'Á¨¨ÂÖ´Âêç',
            'Á¨¨‰πùÂêç': 'Á¨¨‰πùÂêç',
            'Á¨¨ÂçÅÂêç': 'Á¨¨ÂçÅÂêç',
            'Á¨¨1Âêç': 'ÂÜ†ÂÜõ',
            'Á¨¨2Âêç': '‰∫öÂÜõ',
            'Á¨¨3Âêç': 'Â≠£ÂÜõ',
            'Á¨¨4Âêç': 'Á¨¨ÂõõÂêç',
            'Á¨¨5Âêç': 'Á¨¨‰∫îÂêç',
            'Á¨¨6Âêç': 'Á¨¨ÂÖ≠Âêç',
            'Á¨¨7Âêç': 'Á¨¨‰∏ÉÂêç',
            'Á¨¨8Âêç': 'Á¨¨ÂÖ´Âêç',
            'Á¨¨9Âêç': 'Á¨¨‰πùÂêç',
            'Á¨¨10Âêç': 'Á¨¨ÂçÅÂêç',
            'Ââç‰∏Ä': 'ÂÜ†ÂÜõ',
            
            # ÂàÜÁªÑÂêçÊ¨°
            '1-5Âêç': '1-5Âêç',
            '6-10Âêç': '6-10Âêç',
            '1~5Âêç': '1-5Âêç',
            '6~10Âêç': '6-10Âêç',
            'ÂÆö‰ΩçËÉÜ_Á¨¨1~5Âêç': 'ÂÆö‰ΩçËÉÜ_Á¨¨1~5Âêç',
            'ÂÆö‰ΩçËÉÜ_Á¨¨6~10Âêç': 'ÂÆö‰ΩçËÉÜ_Á¨¨6~10Âêç',
            
            # ÁêÉ‰ΩçÁé©Ê≥ïÔºàÊó∂Êó∂ÂΩ©Ôºâ
            'Á¨¨1ÁêÉ': 'Á¨¨1ÁêÉ',
            'Á¨¨2ÁêÉ': 'Á¨¨2ÁêÉ',
            'Á¨¨3ÁêÉ': 'Á¨¨3ÁêÉ',
            'Á¨¨4ÁêÉ': 'Á¨¨4ÁêÉ',
            'Á¨¨5ÁêÉ': 'Á¨¨5ÁêÉ',
            '1-5ÁêÉ': '1-5ÁêÉ',
            
            # ‰ΩçÊï∞Áé©Ê≥ïÔºàÊó∂Êó∂ÂΩ©Ôºâ
            '‰∏á‰Ωç': '‰∏á‰Ωç',
            'ÂçÉ‰Ωç': 'ÂçÉ‰Ωç',
            'Áôæ‰Ωç': 'Áôæ‰Ωç',
            'ÂçÅ‰Ωç': 'ÂçÅ‰Ωç',
            '‰∏™‰Ωç': '‰∏™‰Ωç',
            'ÂÆö‰Ωç_‰∏á‰Ωç': '‰∏á‰Ωç',
            'ÂÆö‰Ωç_ÂçÉ‰Ωç': 'ÂçÉ‰Ωç',
            'ÂÆö‰Ωç_Áôæ‰Ωç': 'Áôæ‰Ωç',
            'ÂÆö‰Ωç_ÂçÅ‰Ωç': 'ÂçÅ‰Ωç',
            'ÂÆö‰Ωç_‰∏™‰Ωç': '‰∏™‰Ωç',
            
            # ========== Âø´‰∏âÂè∑Á†ÅÁé©Ê≥ï ==========
            'ÂíåÂÄº': 'ÂíåÂÄº',
            'ÂíåÂÄº_Â§ßÂ∞èÂçïÂèå': 'ÂíåÂÄº',
            'ÁÇπÊï∞': 'ÂíåÂÄº',
            
            # ========== 3DÁ≥ªÂàóÂè∑Á†ÅÁé©Ê≥ï ==========
            'Áôæ‰Ωç': 'Áôæ‰Ωç',
            'ÂçÅ‰Ωç': 'ÂçÅ‰Ωç',
            '‰∏™‰Ωç': '‰∏™‰Ωç',
            'ÁôæÂçÅ': 'ÁôæÂçÅ',
            'Áôæ‰∏™': 'Áôæ‰∏™',
            'ÂçÅ‰∏™': 'ÂçÅ‰∏™',
            'ÁôæÂçÅ‰∏™': 'ÁôæÂçÅ‰∏™',
            'ÂÆö‰ΩçËÉÜ_Áôæ‰Ωç': 'Áôæ‰Ωç',
            'ÂÆö‰ΩçËÉÜ_ÂçÅ‰Ωç': 'ÂçÅ‰Ωç',
            'ÂÆö‰ΩçËÉÜ_‰∏™‰Ωç': '‰∏™‰Ωç',
            
            # ========== ÂÖ∂‰ªñÂè∑Á†ÅÁé©Ê≥ï ==========
            'ÊÄªÂíå': 'ÊÄªÂíå',
            'ÊñóÁâõ': 'ÊñóÁâõ'
        }

        # Êâ©Â±ïÁé©Ê≥ïÊò†Â∞Ñ
        self.play_mapping.update({
            # üÜï Êñ∞Â¢ûÔºöÂø´‰∏âÂü∫Á°ÄÁé©Ê≥ï
            '‰∏âÂÜõ': '‰∏âÂÜõ',
            '‰∏âËªç': '‰∏âÂÜõ',
            'Áã¨ËÉÜ': '‰∏âÂÜõ', 
            'ÂçïÁ†Å': '‰∏âÂÜõ',
            '‰∫å‰∏çÂêåÂè∑': '‰∫å‰∏çÂêåÂè∑',
            '‰∫å‰∏çÂêå': '‰∫å‰∏çÂêåÂè∑',
            '‰∫å‰∏çÂêåËôü': '‰∫å‰∏çÂêåÂè∑',
            '‰∏â‰∏çÂêåÂè∑': '‰∏â‰∏çÂêåÂè∑',
            '‰∏â‰∏çÂêå': '‰∏â‰∏çÂêåÂè∑',
            '‰∏â‰∏çÂêåËôü': '‰∏â‰∏çÂêåÂè∑',
            
            # üÜï Êñ∞Â¢ûÔºöÂÜ†‰∫öÂíåÁé©Ê≥ï
            'ÂÜ†‰∫öÂíå': 'ÂÜ†‰∫öÂíå',
            'ÂÜ†‰∫öÂíåÂÄº': 'ÂÜ†‰∫öÂíå',
            'ÂÜ†‰∫ûÂíå': 'ÂÜ†‰∫öÂíå',
            'ÂÜ†‰∫ûÂíåÂÄº': 'ÂÜ†‰∫öÂíå',
            
            # üÜï Êâ©Â±ïÔºöÂÖ≠ÂêàÂΩ©Â∞æÊï∞Áé©Ê≥ï
            'Â∞æÊï∞_Â§¥Â∞æÊï∞': 'Â∞æÊï∞_Â§¥Â∞æÊï∞',
            'Â§¥Â∞æÊï∞': 'Â∞æÊï∞_Â§¥Â∞æÊï∞',
            'ÁâπÂ∞æ': 'ÁâπÂ∞æ',
            'ÂÖ®Â∞æ': 'ÂÖ®Â∞æ',
            
            # üÜï Êâ©Â±ïÔºöÊó∂Êó∂ÂΩ©ÁêÉ‰ΩçÁé©Ê≥ï
            'Á¨¨1ÁêÉ': 'Á¨¨1ÁêÉ',
            'Á¨¨2ÁêÉ': 'Á¨¨2ÁêÉ', 
            'Á¨¨3ÁêÉ': 'Á¨¨3ÁêÉ',
            'Á¨¨4ÁêÉ': 'Á¨¨4ÁêÉ',
            'Á¨¨5ÁêÉ': 'Á¨¨5ÁêÉ',
            '1-5ÁêÉ': '1-5ÁêÉ',
            
            # üÜï Êâ©Â±ïÔºö3DÁ≥ªÂàóÁé©Ê≥ï
            'ÁôæÂçÅ': 'ÁôæÂçÅ',
            'Áôæ‰∏™': 'Áôæ‰∏™',
            'ÂçÅ‰∏™': 'ÂçÅ‰∏™',
            'ÁôæÂçÅ‰∏™': 'ÁôæÂçÅ‰∏™'
        })
        
        self.position_mapping = {
            # ========== ÂÖ≠ÂêàÂΩ©‰ΩçÁΩÆ ==========
            'ÁâπÁ†Å': ['ÁâπÁ†Å', 'ÁâπÁéõ', 'ÁâπÈ©¨', 'ÁâπÁ¢º', 'ÁâπÁ†ÅÁêÉ', 'ÁâπÁ†Å_ÁâπÁ†Å', 'ÁâπÁ†ÅA', 'ÁâπÁ†ÅB'],
            'Ê≠£Á†Å': ['Ê≠£Á†Å', 'Ê≠£Á†Å1-6 Ê≠£Á†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†Å', 'Ê≠£Á†Å1-6'],
            'Ê≠£Á†Å‰∏Ä': ['Ê≠£Á†Å‰∏Ä', 'Ê≠£Á†Å1', 'Ê≠£‰∏ÄÁ†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∏Ä', 'Ê≠£1', 'zm1', 'z1m'],
            'Ê≠£Á†Å‰∫å': ['Ê≠£Á†Å‰∫å', 'Ê≠£Á†Å2', 'Ê≠£‰∫åÁ†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∫å', 'Ê≠£2', 'zm2', 'z2m'],
            'Ê≠£Á†Å‰∏â': ['Ê≠£Á†Å‰∏â', 'Ê≠£Á†Å3', 'Ê≠£‰∏âÁ†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∏â', 'Ê≠£3', 'zm3', 'z3m'],
            'Ê≠£Á†ÅÂõõ': ['Ê≠£Á†ÅÂõõ', 'Ê≠£Á†Å4', 'Ê≠£ÂõõÁ†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†ÅÂõõ', 'Ê≠£4', 'zm4', 'z4m'],
            'Ê≠£Á†Å‰∫î': ['Ê≠£Á†Å‰∫î', 'Ê≠£Á†Å5', 'Ê≠£‰∫îÁ†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∫î', 'Ê≠£5', 'zm5', 'z5m'],
            'Ê≠£Á†ÅÂÖ≠': ['Ê≠£Á†ÅÂÖ≠', 'Ê≠£Á†Å6', 'Ê≠£ÂÖ≠Á†Å', 'Ê≠£Á†Å1-6_Ê≠£Á†ÅÂÖ≠', 'Ê≠£6', 'zm6', 'z6m'],
            
            'Ê≠£Áâπ': ['Ê≠£Áâπ', 'Ê≠£ÁéõÁâπ', 'Ê≠£Á†ÅÁâπ'],
            'Ê≠£‰∏ÄÁâπ': ['Ê≠£‰∏ÄÁâπ', 'Ê≠£1Áâπ', 'Ê≠£Á†ÅÁâπ_Ê≠£‰∏ÄÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£‰∏ÄÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£1Áâπ', 'z1t', 'zyte'],
            'Ê≠£‰∫åÁâπ': ['Ê≠£‰∫åÁâπ', 'Ê≠£2Áâπ', 'Ê≠£Á†ÅÁâπ_Ê≠£‰∫åÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£‰∫åÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£2Áâπ', 'z2t', 'zte'],
            'Ê≠£‰∏âÁâπ': ['Ê≠£‰∏âÁâπ', 'Ê≠£3Áâπ', 'Ê≠£Á†ÅÁâπ_Ê≠£‰∏âÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£‰∏âÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£3Áâπ', 'z3t', 'zste'],
            'Ê≠£ÂõõÁâπ': ['Ê≠£ÂõõÁâπ', 'Ê≠£4Áâπ', 'Ê≠£Á†ÅÁâπ_Ê≠£ÂõõÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£ÂõõÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£4Áâπ', 'z4t', 'zsite'],
            'Ê≠£‰∫îÁâπ': ['Ê≠£‰∫îÁâπ', 'Ê≠£5Áâπ', 'Ê≠£Á†ÅÁâπ_Ê≠£‰∫îÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£‰∫îÁâπ', 'Ê≠£ÁéõÁâπ_Ê≠£5Áâπ', 'z5t', 'zwte'],
            'Ê≠£ÂÖ≠Áâπ': ['Ê≠£ÂÖ≠Áâπ', 'Ê≠£6Áâπ', 'Ê≠£Á†ÅÁâπ_Ê≠£ÂÖ≠Áâπ', 'Ê≠£ÁéõÁâπ_Ê≠£ÂÖ≠Áâπ', 'Ê≠£ÁéõÁâπ_Ê≠£6Áâπ', 'z6t', 'zlte'],
            
            'Âπ≥Á†Å': ['Âπ≥Á†Å', 'Âπ≥ÁâπÁ†Å', 'Âπ≥Áâπ', 'pm', 'pingma'],
            'Âπ≥Áâπ': ['Âπ≥Áâπ', 'Âπ≥ÁâπËÇñ', 'Âπ≥ÁâπÁ†Å', 'pt', 'pingte'],
            'Â∞æÊï∞': ['Â∞æÊï∞', 'Â∞æÊï∞_Â§¥Â∞æÊï∞', 'Â∞æÊï∞_Ê≠£ÁâπÂ∞æÊï∞', 'Â∞æÁ†Å', 'ws', 'weishu'],
            'ÁâπÂ∞æ': ['ÁâπÂ∞æ', 'ÁâπÂ∞æÊï∞', 'ÁâπÁ†ÅÂ∞æÊï∞', 'tw', 'tewei'],
            'ÂÖ®Â∞æ': ['ÂÖ®Â∞æ', 'ÂÖ®Â∞æÊï∞', 'ÂÖ®ÈÉ®Â∞æÊï∞', 'qw', 'quanwei'],
            
            # ========== Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶‰ΩçÁΩÆ ==========
            'ÂÜ†ÂÜõ': ['ÂÜ†ÂÜõ', 'Á¨¨‰∏ÄÂêç', 'Á¨¨1Âêç', '1st', 'Ââç‰∏Ä', 'Ââç‰∏Ä‰Ωç', 'Á¨¨‰∏Ä‰Ωç', '1‰Ωç', 'gj', 'guanjun'],
            '‰∫öÂÜõ': ['‰∫öÂÜõ', 'Á¨¨‰∫åÂêç', 'Á¨¨2Âêç', '2nd', 'Ââç‰∫å', 'Á¨¨‰∫å‰Ωç', '2‰Ωç', 'yj', 'yajun'],
            'Â≠£ÂÜõ': ['Â≠£ÂÜõ', 'Á¨¨‰∏âÂêç', 'Á¨¨3Âêç', '3rd', 'Ââç‰∏â', 'Á¨¨‰∏â‰Ωç', '3‰Ωç', 'jj', 'jijun'],
            'Á¨¨ÂõõÂêç': ['Á¨¨ÂõõÂêç', 'Á¨¨4Âêç', '4th', 'Á¨¨Âõõ‰Ωç', '4‰Ωç', 'dsm', 'disiming'],
            'Á¨¨‰∫îÂêç': ['Á¨¨‰∫îÂêç', 'Á¨¨5Âêç', '5th', 'Á¨¨‰∫î‰Ωç', '5‰Ωç', 'dwm', 'diwuming'],
            'Á¨¨ÂÖ≠Âêç': ['Á¨¨ÂÖ≠Âêç', 'Á¨¨6Âêç', '6th', 'Á¨¨ÂÖ≠‰Ωç', '6‰Ωç', 'dlm', 'diliuming'],
            'Á¨¨‰∏ÉÂêç': ['Á¨¨‰∏ÉÂêç', 'Á¨¨7Âêç', '7th', 'Á¨¨‰∏É‰Ωç', '7‰Ωç', 'dqm', 'diqiming'],
            'Á¨¨ÂÖ´Âêç': ['Á¨¨ÂÖ´Âêç', 'Á¨¨8Âêç', '8th', 'Á¨¨ÂÖ´‰Ωç', '8‰Ωç', 'dbm', 'dibaming'],
            'Á¨¨‰πùÂêç': ['Á¨¨‰πùÂêç', 'Á¨¨9Âêç', '9th', 'Á¨¨‰πù‰Ωç', '9‰Ωç', 'djm', 'dijiuming'],
            'Á¨¨ÂçÅÂêç': ['Á¨¨ÂçÅÂêç', 'Á¨¨10Âêç', '10th', 'Á¨¨ÂçÅ‰Ωç', '10‰Ωç', 'dsm2', 'dishiming'],
            
            'Á¨¨1ÁêÉ': ['Á¨¨1ÁêÉ', 'Á¨¨‰∏ÄÁêÉ', '‰∏á‰Ωç', 'Á¨¨‰∏Ä‰Ωç', 'ÂÆö‰Ωç_‰∏á‰Ωç', '‰∏á‰ΩçÂÆö‰Ωç', 'd1q', 'di1qiu'],
            'Á¨¨2ÁêÉ': ['Á¨¨2ÁêÉ', 'Á¨¨‰∫åÁêÉ', 'ÂçÉ‰Ωç', 'Á¨¨‰∫å‰Ωç', 'ÂÆö‰Ωç_ÂçÉ‰Ωç', 'ÂçÉ‰ΩçÂÆö‰Ωç', 'd2q', 'di2qiu'],
            'Á¨¨3ÁêÉ': ['Á¨¨3ÁêÉ', 'Á¨¨‰∏âÁêÉ', 'Áôæ‰Ωç', 'Á¨¨‰∏â‰Ωç', 'ÂÆö‰Ωç_Áôæ‰Ωç', 'Áôæ‰ΩçÂÆö‰Ωç', 'd3q', 'di3qiu'],
            'Á¨¨4ÁêÉ': ['Á¨¨4ÁêÉ', 'Á¨¨ÂõõÁêÉ', 'ÂçÅ‰Ωç', 'Á¨¨Âõõ‰Ωç', 'ÂÆö‰Ωç_ÂçÅ‰Ωç', 'ÂçÅ‰ΩçÂÆö‰Ωç', 'd4q', 'di4qiu'],
            'Á¨¨5ÁêÉ': ['Á¨¨5ÁêÉ', 'Á¨¨‰∫îÁêÉ', '‰∏™‰Ωç', 'Á¨¨‰∫î‰Ωç', 'ÂÆö‰Ωç_‰∏™‰Ωç', '‰∏™‰ΩçÂÆö‰Ωç', 'd5q', 'di5qiu'],
            
            '1-5Âêç': ['1-5Âêç', '1~5Âêç', '1Ëá≥5Âêç', '1Âà∞5Âêç', 'Ââç‰∫îÂêç', '1-5ming'],
            '6-10Âêç': ['6-10Âêç', '6~10Âêç', '6Ëá≥10Âêç', '6Âà∞10Âêç', 'Âêé‰∫îÂêç', '6-10ming'],
            'ÂÆö‰ΩçËÉÜ_Á¨¨1~5Âêç': ['ÂÆö‰ΩçËÉÜ_Á¨¨1~5Âêç', 'ÂÆö‰ΩçËÉÜ1-5Âêç', '1-5ÂêçÂÆö‰ΩçËÉÜ'],
            'ÂÆö‰ΩçËÉÜ_Á¨¨6~10Âêç': ['ÂÆö‰ΩçËÉÜ_Á¨¨6~10Âêç', 'ÂÆö‰ΩçËÉÜ6-10Âêç', '6-10ÂêçÂÆö‰ΩçËÉÜ'],
            
            # ========== Âø´‰∏â‰ΩçÁΩÆ ==========
            'ÂíåÂÄº': ['ÂíåÂÄº', 'ÂíåÊï∞', 'Âíå', 'ÂíåÂÄº_Â§ßÂ∞èÂçïÂèå', 'ÁÇπÊï∞', 'hz', 'hezhi'],
            '‰∏âÂÜõ': ['‰∏âÂÜõ', '‰∏âËªç', 'Áã¨ËÉÜ', 'ÂçïÁ†Å', 'sj', 'sanjun'],
            '‰∫å‰∏çÂêåÂè∑': ['‰∫å‰∏çÂêåÂè∑', '‰∫å‰∏çÂêå', '‰∫å‰∏çÂêåËôü', 'ebth', 'erbutonghao'],
            '‰∏â‰∏çÂêåÂè∑': ['‰∏â‰∏çÂêåÂè∑', '‰∏â‰∏çÂêå', '‰∏â‰∏çÂêåËôü', 'sbth', 'sanbutonghao'],
            
            # ========== 3DÁ≥ªÂàó‰ΩçÁΩÆ ==========
            'Áôæ‰Ωç': ['Áôæ‰Ωç', 'ÂÆö‰Ωç_Áôæ‰Ωç', 'Áôæ‰ΩçÂÆö‰Ωç', 'bw', 'baiwei', 'Á¨¨1‰Ωç_3D'],
            'ÂçÅ‰Ωç': ['ÂçÅ‰Ωç', 'ÂÆö‰Ωç_ÂçÅ‰Ωç', 'ÂçÅ‰ΩçÂÆö‰Ωç', 'sw', 'shiwei', 'Á¨¨2‰Ωç_3D'],
            '‰∏™‰Ωç': ['‰∏™‰Ωç', 'ÂÆö‰Ωç_‰∏™‰Ωç', '‰∏™‰ΩçÂÆö‰Ωç', 'gw', 'gewei', 'Á¨¨3‰Ωç_3D'],
            'ÁôæÂçÅ': ['ÁôæÂçÅ', 'ÁôæÂçÅ‰Ωç', 'ÁôæÂçÅÂÆö‰Ωç', 'bs', 'baishi'],
            'Áôæ‰∏™': ['Áôæ‰∏™', 'Áôæ‰∏™‰Ωç', 'Áôæ‰∏™ÂÆö‰Ωç', 'bg', 'baige'],
            'ÂçÅ‰∏™': ['ÂçÅ‰∏™', 'ÂçÅ‰∏™‰Ωç', 'ÂçÅ‰∏™ÂÆö‰Ωç', 'sg', 'shige'],
            'ÁôæÂçÅ‰∏™': ['ÁôæÂçÅ‰∏™', 'ÁôæÂçÅ‰∏™‰Ωç', 'ÁôæÂçÅ‰∏™ÂÆö‰Ωç', 'bsg', 'baishige'],
            
            # ========== ‰∫îÊòüÂΩ©‰ΩçÁΩÆ ==========
            '‰∏á‰Ωç': ['‰∏á‰Ωç', 'Á¨¨1‰Ωç', 'Á¨¨‰∏Ä‰Ωç', '1st', 'ww', 'wanwei'],
            'ÂçÉ‰Ωç': ['ÂçÉ‰Ωç', 'Á¨¨2‰Ωç', 'Á¨¨‰∫å‰Ωç', '2nd', 'qw', 'qianwei'],
            'Áôæ‰Ωç_5x': ['Áôæ‰Ωç_5x', 'Á¨¨3‰Ωç', 'Á¨¨‰∏â‰Ωç', '3rd', 'bw5', 'baiwei5'],
            'ÂçÅ‰Ωç_5x': ['ÂçÅ‰Ωç_5x', 'Á¨¨4‰Ωç', 'Á¨¨Âõõ‰Ωç', '4th', 'sw5', 'shiwei5'],
            '‰∏™‰Ωç_5x': ['‰∏™‰Ωç_5x', 'Á¨¨5‰Ωç', 'Á¨¨‰∫î‰Ωç', '5th', 'gw5', 'gewei5'],
            
            # ========== Âø´‰πê8‰ΩçÁΩÆ ==========
            'ÈÄâ‰∏Ä': ['ÈÄâ‰∏Ä', '‰∏Ä‰∏≠‰∏Ä', '1‰∏≠1', 'ÈÄâ1', 'xuan1', 'x1'],
            'ÈÄâ‰∫å': ['ÈÄâ‰∫å', '‰∫å‰∏≠‰∫å', '2‰∏≠2', 'ÈÄâ2', 'xuan2', 'x2'],
            'ÈÄâ‰∏â': ['ÈÄâ‰∏â', '‰∏â‰∏≠‰∏â', '3‰∏≠3', 'ÈÄâ3', 'xuan3', 'x3'],
            'ÈÄâÂõõ': ['ÈÄâÂõõ', 'Âõõ‰∏≠Âõõ', '4‰∏≠4', 'ÈÄâ4', 'xuan4', 'x4'],
            'ÈÄâ‰∫î': ['ÈÄâ‰∫î', '‰∫î‰∏≠‰∫î', '5‰∏≠5', 'ÈÄâ5', 'xuan5', 'x5'],
            'ÈÄâÂÖ≠': ['ÈÄâÂÖ≠', 'ÂÖ≠‰∏≠ÂÖ≠', '6‰∏≠6', 'ÈÄâ6', 'xuan6', 'x6'],
            'ÈÄâ‰∏É': ['ÈÄâ‰∏É', '‰∏É‰∏≠‰∏É', '7‰∏≠7', 'ÈÄâ7', 'xuan7', 'x7'],
            'ÈÄâÂÖ´': ['ÈÄâÂÖ´', 'ÂÖ´‰∏≠ÂÖ´', '8‰∏≠8', 'ÈÄâ8', 'xuan8', 'x8'],
            'ÈÄâ‰πù': ['ÈÄâ‰πù', '‰πù‰∏≠‰πù', '9‰∏≠9', 'ÈÄâ9', 'xuan9', 'x9'],
            'ÈÄâÂçÅ': ['ÈÄâÂçÅ', 'ÂçÅ‰∏≠ÂçÅ', '10‰∏≠10', 'ÈÄâ10', 'xuan10', 'x10']
        }

        # Êâ©Â±ï‰ΩçÁΩÆÊò†Â∞Ñ
        self.position_mapping.update({
            # üÜï Êñ∞Â¢ûÔºöÂø´‰∏âÂü∫Á°ÄÁé©Ê≥ï‰ΩçÁΩÆ
            '‰∏âÂÜõ': ['‰∏âÂÜõ', '‰∏âËªç', 'Áã¨ËÉÜ', 'ÂçïÁ†Å', 'sj', 'sanjun'],
            '‰∫å‰∏çÂêåÂè∑': ['‰∫å‰∏çÂêåÂè∑', '‰∫å‰∏çÂêå', '‰∫å‰∏çÂêåËôü', 'ebth', 'erbutonghao'],
            '‰∏â‰∏çÂêåÂè∑': ['‰∏â‰∏çÂêåÂè∑', '‰∏â‰∏çÂêå', '‰∏â‰∏çÂêåËôü', 'sbth', 'sanbutonghao'],
            
            # üÜï Êñ∞Â¢ûÔºöÂÜ†‰∫öÂíå‰ΩçÁΩÆ
            'ÂÜ†‰∫öÂíå': ['ÂÜ†‰∫öÂíå', 'ÂÜ†‰∫öÂíåÂÄº', 'ÂÜ†‰∫ûÂíå', 'ÂÜ†‰∫ûÂíåÂÄº', 'gyh', 'guanyabe'],
            
            # üÜï Êâ©Â±ïÔºöÂÖ≠ÂêàÂΩ©Â∞æÊï∞‰ΩçÁΩÆ
            'Â∞æÊï∞_Â§¥Â∞æÊï∞': ['Â∞æÊï∞_Â§¥Â∞æÊï∞', 'Â§¥Â∞æÊï∞', 'Â§¥Â∞æ', 'Â∞æÊï∞Â§¥Â∞æ', 'tws', 'touweishu'],
            'ÁâπÂ∞æ': ['ÁâπÂ∞æ', 'ÁâπÂ∞æÊï∞', 'ÁâπÁ†ÅÂ∞æÊï∞', 'tw', 'tewei'],
            'ÂÖ®Â∞æ': ['ÂÖ®Â∞æ', 'ÂÖ®Â∞æÊï∞', 'ÂÖ®ÈÉ®Â∞æÊï∞', 'qw', 'quanwei'],
            
            # üÜï Êâ©Â±ïÔºöÊó∂Êó∂ÂΩ©ÁêÉ‰Ωç
            'Á¨¨1ÁêÉ': ['Á¨¨1ÁêÉ', 'Á¨¨‰∏ÄÁêÉ', '‰∏á‰Ωç', 'Á¨¨‰∏Ä‰Ωç', 'ÂÆö‰Ωç_‰∏á‰Ωç', '‰∏á‰ΩçÂÆö‰Ωç', 'd1q', 'di1qiu'],
            'Á¨¨2ÁêÉ': ['Á¨¨2ÁêÉ', 'Á¨¨‰∫åÁêÉ', 'ÂçÉ‰Ωç', 'Á¨¨‰∫å‰Ωç', 'ÂÆö‰Ωç_ÂçÉ‰Ωç', 'ÂçÉ‰ΩçÂÆö‰Ωç', 'd2q', 'di2qiu'],
            'Á¨¨3ÁêÉ': ['Á¨¨3ÁêÉ', 'Á¨¨‰∏âÁêÉ', 'Áôæ‰Ωç', 'Á¨¨‰∏â‰Ωç', 'ÂÆö‰Ωç_Áôæ‰Ωç', 'Áôæ‰ΩçÂÆö‰Ωç', 'd3q', 'di3qiu'],
            'Á¨¨4ÁêÉ': ['Á¨¨4ÁêÉ', 'Á¨¨ÂõõÁêÉ', 'ÂçÅ‰Ωç', 'Á¨¨Âõõ‰Ωç', 'ÂÆö‰Ωç_ÂçÅ‰Ωç', 'ÂçÅ‰ΩçÂÆö‰Ωç', 'd4q', 'di4qiu'],
            'Á¨¨5ÁêÉ': ['Á¨¨5ÁêÉ', 'Á¨¨‰∫îÁêÉ', '‰∏™‰Ωç', 'Á¨¨‰∫î‰Ωç', 'ÂÆö‰Ωç_‰∏™‰Ωç', '‰∏™‰ΩçÂÆö‰Ωç', 'd5q', 'di5qiu'],
            
            # üÜï Êâ©Â±ïÔºö3DÁ≥ªÂàó‰ΩçÁΩÆ
            'ÁôæÂçÅ': ['ÁôæÂçÅ', 'ÁôæÂçÅ‰Ωç', 'ÁôæÂçÅÂÆö‰Ωç', 'bs', 'baishi'],
            'Áôæ‰∏™': ['Áôæ‰∏™', 'Áôæ‰∏™‰Ωç', 'Áôæ‰∏™ÂÆö‰Ωç', 'bg', 'baige'],
            'ÂçÅ‰∏™': ['ÂçÅ‰∏™', 'ÂçÅ‰∏™‰Ωç', 'ÂçÅ‰∏™ÂÆö‰Ωç', 'sg', 'shige'],
            'ÁôæÂçÅ‰∏™': ['ÁôæÂçÅ‰∏™', 'ÁôæÂçÅ‰∏™‰Ωç', 'ÁôæÂçÅ‰∏™ÂÆö‰Ωç', 'bsg', 'baishige']
        })

    def filter_number_bets_only(self, df):
        """ËøáÊª§Âè™‰øùÁïôÊ∂âÂèäÂÖ∑‰ΩìÂè∑Á†ÅÊäïÊ≥®ÁöÑËÆ∞ÂΩï - ‰øÆÂ§çÁâàÊú¨"""
        
        # ÂÆö‰πâÈùûÂè∑Á†ÅÊäïÊ≥®ÁöÑÂÖ≥ÈîÆËØç - Âè™ËøáÊª§ÊòéÁ°ÆÁöÑÂ§ßÂ∞èÂçïÂèåÁ≠â
        non_number_keywords = [
            'Â§ßÂ∞è', 'ÂçïÂèå', 'ÈæôËôé', 'ÂíåÂÄºÂ§ßÂ∞è', 'ÂíåÂÄºÂçïÂèå', 'ÁâπÂçï', 'ÁâπÂèå', 'ÁâπÂ§ß', 'ÁâπÂ∞è',
            'Â§ß', 'Â∞è', 'Âçï', 'Âèå', 'Èæô', 'Ëôé', 'ÂêàÊï∞ÂçïÂèå', 'ÂêàÊï∞Â§ßÂ∞è', 'Â∞æÊï∞Â§ßÂ∞è',
            'Â∞æÊï∞ÂçïÂèå', 'ÊÄªÂíåÂ§ßÂ∞è', 'ÊÄªÂíåÂçïÂèå'
        ]
        
        # ÂÆö‰πâÈúÄË¶Å‰øùÁïôÁöÑÂè∑Á†ÅÊäïÊ≥®Áé©Ê≥ï - Êâ©Â±ïÂ∞æÊï∞Áõ∏ÂÖ≥Áé©Ê≥ï
        number_play_keywords = [
            'ÁâπÁ†Å', 'Ê≠£Á†Å', 'Âπ≥Á†Å', 'Âπ≥Áâπ', 'Â∞æÊï∞', 'ÁâπÂ∞æ', 'ÂÖ®Â∞æ',  # ÂÖ≠ÂêàÂΩ©
            'Ê≠£Áâπ', 'Ê≠£‰∏ÄÁâπ', 'Ê≠£‰∫åÁâπ', 'Ê≠£‰∏âÁâπ', 'Ê≠£ÂõõÁâπ', 'Ê≠£‰∫îÁâπ', 'Ê≠£ÂÖ≠Áâπ',  # Êñ∞Â¢ûÊ≠£Á†ÅÁâπ
            'Ê≠£1Áâπ', 'Ê≠£2Áâπ', 'Ê≠£3Áâπ', 'Ê≠£4Áâπ', 'Ê≠£5Áâπ', 'Ê≠£6Áâπ',  # Êñ∞Â¢ûÊï∞Â≠óÊ†ºÂºè
            'Ê≠£ÁéõÁâπ', 'Ê≠£Á†ÅÁâπ',  # Êñ∞Â¢ûÂèò‰Ωì
            'ÂÆö‰ΩçËÉÜ', 'ÂÜ†ÂÜõ', '‰∫öÂÜõ', 'Â≠£ÂÜõ', 'Á¨¨ÂõõÂêç', 'Á¨¨‰∫îÂêç', 'Á¨¨ÂÖ≠Âêç',  # PK10/ËµõËΩ¶
            'Á¨¨‰∏ÉÂêç', 'Á¨¨ÂÖ´Âêç', 'Á¨¨‰πùÂêç', 'Á¨¨ÂçÅÂêç', 'Ââç‰∏Ä',  # PK10/ËµõËΩ¶
            'ÂíåÂÄº', 'ÁÇπÊï∞',  # Âø´‰∏âÔºàÂÖ∑‰ΩìÊï∞Â≠óÔºâ
            'Áôæ‰Ωç', 'ÂçÅ‰Ωç', '‰∏™‰Ωç', 'ÁôæÂçÅ', 'Áôæ‰∏™', 'ÂçÅ‰∏™', 'ÁôæÂçÅ‰∏™'  # 3DÁ≥ªÂàó
            # üÜï Ê≥®ÊÑèÔºöÁßªÈô§‰∫Ü 'Â∞æÊï∞_Â§¥Â∞æÊï∞'ÔºåÂõ†‰∏∫ÂÆûÈôÖÁé©Ê≥ïÊòØ 'Â∞æÊï∞'„ÄÅ'ÂÖ®Â∞æ'„ÄÅ'ÁâπÂ∞æ'
        ]
        
        # ËøáÊª§Êù°‰ª∂1ÔºöÁé©Ê≥ïÂøÖÈ°ªÂåÖÂê´Âè∑Á†ÅÊäïÊ≥®ÂÖ≥ÈîÆËØç
        play_condition = df['Áé©Ê≥ï'].str.contains('|'.join(number_play_keywords), na=False)
        
        # ËøáÊª§Êù°‰ª∂2ÔºöÊäïÊ≥®ÂÜÖÂÆπ‰∏çËÉΩÂåÖÂê´ÈùûÂè∑Á†ÅÂÖ≥ÈîÆËØç
        content_condition = ~df['ÂÜÖÂÆπ'].str.contains('|'.join(non_number_keywords), na=False)
        
        # ËøáÊª§Êù°‰ª∂3ÔºöÊäïÊ≥®ÂÜÖÂÆπÂøÖÈ°ªÂåÖÂê´Êï∞Â≠ó
        number_condition = df['ÂÜÖÂÆπ'].str.contains(r'\d', na=False)
        
        # ÁªºÂêàÊù°‰ª∂ÔºöÁé©Ê≥ïÊ≠£Á°Æ ‰∏î (ÂÜÖÂÆπ‰∏çÂåÖÂê´ÈùûÂè∑Á†ÅÂÖ≥ÈîÆËØç Êàñ ÂÜÖÂÆπÂåÖÂê´Êï∞Â≠ó)
        final_condition = play_condition & (content_condition | number_condition)
        
        filtered_df = df[final_condition].copy()
        
        # ËÆ∞ÂΩïËøáÊª§ÁªüËÆ°
        removed_count = len(df) - len(filtered_df)
        logger.info(f"üìä ËøáÊª§ÈùûÂè∑Á†ÅÊäïÊ≥®: ÁßªÈô§ {removed_count} Êù°ËÆ∞ÂΩïÔºå‰øùÁïô {len(filtered_df)} Êù°ËÆ∞ÂΩï")
        
        return filtered_df

    def filter_records_with_numbers(self, df):
        """ËøáÊª§Âè™‰øùÁïôÂåÖÂê´ÊúâÊïàÂè∑Á†ÅÁöÑÊäïÊ≥®ËÆ∞ÂΩï"""
        
        # ÂÆö‰πâÂêÑÂΩ©ÁßçÁöÑÂè∑Á†ÅËåÉÂõ¥
        lottery_configs = {
            'six_mark': set(range(1, 50)),
            '10_number': set(range(1, 11)),
            'fast_three': set(range(3, 19))
        }
        
        # ËØÜÂà´ÂΩ©ÁßçÁ±ªÂûã
        if 'ÂΩ©ÁßçÁ±ªÂûã' not in df.columns:
            df['ÂΩ©ÁßçÁ±ªÂûã'] = df['ÂΩ©Áßç'].apply(self.identify_lottery_category)
        
        # ÊèêÂèñÂè∑Á†ÅÂπ∂ËøáÊª§
        valid_records = []
        
        for idx, row in df.iterrows():
            lottery_category = row['ÂΩ©ÁßçÁ±ªÂûã']
            
            if pd.isna(lottery_category):
                continue
                
            # ÊèêÂèñÂè∑Á†Å
            numbers = self.cached_extract_numbers(row['ÂÜÖÂÆπ'], lottery_category)
            
            # Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÊúâÊïàÂè∑Á†Å
            if numbers:
                valid_records.append(idx)
        
        filtered_df = df.loc[valid_records].copy()
        
        # ËÆ∞ÂΩïËøáÊª§ÁªüËÆ°
        removed_count = len(df) - len(filtered_df)
        logger.info(f"üìä ËøáÊª§Êó†Âè∑Á†ÅÊäïÊ≥®: ÁßªÈô§ {removed_count} Êù°ËÆ∞ÂΩïÔºå‰øùÁïô {len(filtered_df)} Êù°ËÆ∞ÂΩï")
        
        # ÊòæÁ§∫Ë¢´ËøáÊª§ÁöÑËÆ∞ÂΩïÁ±ªÂûã
        if removed_count > 0:
            removed_df = df.drop(valid_records)
            st.info(f"üîç ËøáÊª§ÁªüËÆ°: ÁßªÈô§‰∫Ü {removed_count} Êù°Êó†Âè∑Á†ÅÊäïÊ≥®ËÆ∞ÂΩï")
            
            if not removed_df.empty:
                with st.expander("Êü•ÁúãË¢´ËøáÊª§ÁöÑËÆ∞ÂΩïÊ†∑Êú¨", expanded=False):
                    st.write("Ë¢´ËøáÊª§ÁöÑÁé©Ê≥ïÂàÜÂ∏É:")
                    play_dist = removed_df['Áé©Ê≥ï'].value_counts().head(10)
                    st.dataframe(play_dist.reset_index().rename(columns={'index': 'Áé©Ê≥ï', 'Áé©Ê≥ï': 'Êï∞Èáè'}))
                    
                    st.write("Ë¢´ËøáÊª§ÁöÑËÆ∞ÂΩïÊ†∑Êú¨:")
                    st.dataframe(removed_df[['‰ºöÂëòË¥¶Âè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï', 'ÂÜÖÂÆπ', 'ÈáëÈ¢ù']].head(10))
        
        return filtered_df

    def fixed_extract_amount(self, amount_str):
        """‰øÆÂ§çÁöÑÈáëÈ¢ùÊèêÂèñÊñπÊ≥ï"""
        return self.cached_extract_amount(str(amount_str))

    def enhanced_data_preprocessing(self, df_clean):
        """Â¢ûÂº∫Êï∞ÊçÆÈ¢ÑÂ§ÑÁêÜÊµÅÁ®ã"""
        # 1. È¶ñÂÖàËØÜÂà´ÂΩ©ÁßçÁ±ªÂûã
        df_clean['ÂΩ©ÁßçÁ±ªÂûã'] = df_clean['ÂΩ©Áßç'].apply(self.identify_lottery_category)
        
        # 2. Áªü‰∏ÄÁé©Ê≥ïÂàÜÁ±ª - Á°Æ‰øùÂ∞æÊï∞Áé©Ê≥ïË¢´Ê≠£Á°ÆËØÜÂà´
        df_clean['Áé©Ê≥ï'] = df_clean.apply(
            lambda row: self.normalize_play_category(
                row['Áé©Ê≥ï'], 
                row['ÂΩ©ÁßçÁ±ªÂûã'] if not pd.isna(row['ÂΩ©ÁßçÁ±ªÂûã']) else 'six_mark'
            ), 
            axis=1
        )
        
        # 3. ÊèêÂèñÂè∑Á†Å - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÁé©Ê≥ïÂíåÂΩ©ÁßçÁ±ªÂûã
        df_clean['ÊèêÂèñÂè∑Á†Å'] = df_clean.apply(
            lambda row: self.cached_extract_numbers(
                row['ÂÜÖÂÆπ'], 
                row['ÂΩ©ÁßçÁ±ªÂûã'] if not pd.isna(row['ÂΩ©ÁßçÁ±ªÂûã']) else 'six_mark',
                row['Áé©Ê≥ï']  # üÜï ‰º†ÈÄíÁé©Ê≥ï‰ø°ÊÅØÁî®‰∫éÂ∞æÊï∞ËØÜÂà´
            ), 
            axis=1
        )
        
        # 4. ËøáÊª§Êó†Âè∑Á†ÅËÆ∞ÂΩï
        initial_count = len(df_clean)
        df_clean = df_clean[df_clean['ÊèêÂèñÂè∑Á†Å'].apply(lambda x: len(x) > 0)]
        no_number_count = initial_count - len(df_clean)
        
        # 5. ËøáÊª§ÈùûÂè∑Á†ÅÊäïÊ≥®Áé©Ê≥ï
        df_clean = self.filter_number_bets_only(df_clean)
        non_number_play_count = initial_count - no_number_count - len(df_clean)
        
        return df_clean, no_number_count, non_number_play_count

    def get_lottery_thresholds(self, lottery_category, user_min_avg_amount):
        """Ê†πÊçÆÂΩ©ÁßçÁ±ªÂûãËé∑ÂèñÈòàÂÄºÈÖçÁΩÆ - ‰øÆÂ§çÁâàÊú¨"""
        base_thresholds = {
            'six_mark': {
                'min_avg_amount': float(user_min_avg_amount),  # ‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆ
                'description': 'ÂÖ≠ÂêàÂΩ©'
            },
            '10_number': {
                'min_avg_amount': float(user_min_avg_amount),  # ‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆ
                'description': 'Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶'
            },
            'fast_three': {
                'min_avg_amount': float(user_min_avg_amount),  # ‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆ
                'description': 'Âø´‰∏â'
            },
            '3d_series': {
                'min_avg_amount': float(user_min_avg_amount),  # ‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆ
                'description': '3DÁ≥ªÂàó'
            },
            'five_star': {
                'min_avg_amount': float(user_min_avg_amount),  # ‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆ
                'description': '‰∫îÊòüÂΩ©'
            }
        }
        
        config = base_thresholds.get(lottery_category, {
            'min_avg_amount': float(user_min_avg_amount),  # ÂÖ∂‰ªñÂΩ©Áßç‰πü‰ΩøÁî®Áî®Êà∑ËÆæÁΩÆ
            'description': 'ÂÖ∂‰ªñÂΩ©Áßç'
        })
        
        return config
    
    def identify_lottery_category(self, lottery_name):
        """ËØÜÂà´ÂΩ©ÁßçÁ±ªÂûã - Â¢ûÂº∫ÂÖ≠ÂêàÂΩ©ËØÜÂà´"""
        lottery_str = str(lottery_name).strip().lower()
        
        # Ê£ÄÊü•ÂÖ≠ÂêàÂΩ©
        for lottery in self.target_lotteries['six_mark']:
            if lottery.lower() in lottery_str:
                return 'six_mark'
        
        # Ê£ÄÊü•Âø´‰∏âÂΩ©Áßç
        for lottery in self.target_lotteries['fast_three']:
            if lottery.lower() in lottery_str:
                return 'fast_three'
        
        # Ê£ÄÊü•10‰∏™Âè∑Á†ÅÁöÑÂΩ©Áßç
        for lottery in self.target_lotteries['10_number']:
            if lottery.lower() in lottery_str:
                return '10_number'

        if any(word in lottery_str for word in ['ÊéíÂàó‰∏â', 'ÊéíÂàó3', 'Á¶èÂΩ©3d', '3d', 'ÊûÅÈÄü3d', 'ÊéíÂàó', 'p3', 'p‰∏â']):
            return '3d_series'
        
        if any(word in lottery_str for word in ['‰∏âËâ≤', '‰∏âËâ≤ÂΩ©', '‰∏âËâ≤ÁêÉ']):
            return 'three_color'

        lottery_keywords_mapping = {
            'six_mark': ['ÂÖ≠Âêà', 'lhc', '‚ë•Âêà', '6Âêà', 'ÁâπÁ†Å', 'Âπ≥Áâπ', 'ËøûËÇñ', 'ÂÖ≠ÂêàÂΩ©', 'Â§ß‰πêÈÄè'],
            '10_number': ['pk10', 'pkÊãæ', 'È£ûËâá', 'ËµõËΩ¶', 'ËµõËªä', 'Âπ∏Ëøê10', 'Âåó‰∫¨ËµõËΩ¶', 'ÊûÅÈÄüËµõËΩ¶', 
                         'Êó∂Êó∂ÂΩ©', 'ssc', 'ÂàÜÂàÜÂΩ©', 'ÊôÇÊôÇÂΩ©', 'ÈáçÂ∫ÜÊó∂Êó∂ÂΩ©', 'ËÖæËÆØÂàÜÂàÜÂΩ©'],
            'fast_three': ['Âø´‰∏â', 'Âø´3', 'k3', 'k‰∏â', 'È™∞ÂÆù', '‰∏âÂÜõ', 'ÂíåÂÄº', 'ÁÇπÊï∞'],
            '3d_series': ['ÊéíÂàó‰∏â', 'ÊéíÂàó3', 'Á¶èÂΩ©3d', '3d', 'ÊûÅÈÄü3d', 'ÊéíÂàó', 'p3', 'p‰∏â'],
            'three_color': ['‰∏âËâ≤', '‰∏âËâ≤ÂΩ©', '‰∏âËâ≤ÁêÉ']
        }
        
        for category, keywords in lottery_keywords_mapping.items():
            for keyword in keywords:
                if keyword in lottery_str:
                    return category
        
        # Ê®°Á≥äÂåπÈÖç
        if any(word in lottery_str for word in ['ÂÖ≠Âêà', 'lhc', '‚ë•Âêà', '6Âêà']):
            return 'six_mark'
        elif any(word in lottery_str for word in ['Âø´‰∏â', 'Âø´3', 'k3']):
            return 'fast_three'
        elif any(word in lottery_str for word in ['Êó∂Êó∂ÂΩ©', 'ssc']):
            return '10_number'
        elif any(word in lottery_str for word in ['pk10', 'pkÊãæ', 'ËµõËΩ¶']):
            return '10_number'
        elif any(word in lottery_str for word in ['28', 'Âπ∏Ëøê28']):
            return '10_number'
        
        return None
    
    def get_lottery_config(self, lottery_category):
        """Ëé∑ÂèñÂΩ©ÁßçÈÖçÁΩÆ"""
        return self.lottery_configs.get(lottery_category, self.lottery_configs['six_mark'])

    def get_play_specific_config(self, lottery_category, play_method):
        """Ê†πÊçÆÁé©Ê≥ïÂíåÂΩ©ÁßçÁ±ªÂûãËé∑ÂèñÂÖ∑‰ΩìÁöÑÈÖçÁΩÆ"""
        play_str = str(play_method).strip().lower() if play_method else ""
        
        # üÜï ÂÖ≠ÂêàÂΩ©Â∞æÊï∞Áé©Ê≥ï
        if lottery_category == 'six_mark' and any(keyword in play_str for keyword in ['Â∞æÊï∞', 'ÂÖ®Â∞æ', 'ÁâπÂ∞æ']):
            return self.lottery_configs['six_mark_tail']
        
        # üÜï Âø´‰∏âÂü∫Á°ÄÁé©Ê≥ï
        elif lottery_category == 'fast_three' and any(keyword in play_str for keyword in ['‰∏âÂÜõ', 'Áã¨ËÉÜ', 'ÂçïÁ†Å', '‰∫å‰∏çÂêåÂè∑', '‰∏â‰∏çÂêåÂè∑']):
            return self.lottery_configs['fast_three_base']
        
        # üÜï Âø´‰∏âÂíåÂÄºÁé©Ê≥ï
        elif lottery_category == 'fast_three' and any(keyword in play_str for keyword in ['ÂíåÂÄº', 'ÁÇπÊï∞']):
            return self.lottery_configs['fast_three_sum']
        
        # üÜï ÂÜ†‰∫öÂíåÁé©Ê≥ï
        elif lottery_category == '10_number' and any(keyword in play_str for keyword in ['ÂÜ†‰∫öÂíå', 'ÂÜ†‰∫öÂíåÂÄº']):
            return self.lottery_configs['10_number_sum']
        
        # üÜï Êó∂Êó∂ÂΩ©Âíå3DÁ≥ªÂàó
        elif lottery_category in ['10_number', '3d_series'] and any(keyword in play_str for keyword in ['Á¨¨1ÁêÉ', 'Á¨¨2ÁêÉ', 'Á¨¨3ÁêÉ', 'Á¨¨4ÁêÉ', 'Á¨¨5ÁêÉ', '‰∏á‰Ωç', 'ÂçÉ‰Ωç', 'Áôæ‰Ωç', 'ÂçÅ‰Ωç', '‰∏™‰Ωç']):
            return self.lottery_configs['ssc_3d']
        
        # ÈªòËÆ§ÈÖçÁΩÆ
        return self.lottery_configs.get(lottery_category, self.lottery_configs['six_mark'])
    
    def enhanced_column_mapping(self, df):
        """Â¢ûÂº∫ÁâàÂàóÂêçËØÜÂà´"""
        column_mapping = {}
        actual_columns = [str(col).strip() for col in df.columns]
        
        for standard_col, possible_names in self.column_mappings.items():
            found = False
            for actual_col in actual_columns:
                actual_col_lower = actual_col.lower().replace(' ', '').replace('_', '').replace('-', '')
                
                for possible_name in possible_names:
                    possible_name_lower = possible_name.lower().replace(' ', '').replace('_', '').replace('-', '')
                    
                    if (possible_name_lower in actual_col_lower or 
                        actual_col_lower in possible_name_lower or
                        len(set(possible_name_lower) & set(actual_col_lower)) / len(possible_name_lower) > 0.7):
                        column_mapping[actual_col] = standard_col
                        found = True
                        break
                if found:
                    break
            
            if not found:
                st.warning(f"‚ö†Ô∏è Êú™ËØÜÂà´Âà∞ {standard_col} ÂØπÂ∫îÁöÑÂàóÂêç")
        
        # Ê£ÄÊü•ÂøÖË¶ÅÂàóÊòØÂê¶ÈÉΩÂ∑≤ËØÜÂà´
        required_columns = ['‰ºöÂëòË¥¶Âè∑', 'ÂΩ©Áßç', 'ÊúüÂè∑', 'Áé©Ê≥ï', 'ÂÜÖÂÆπ']
        missing_columns = [col for col in required_columns if col not in column_mapping.values()]
        
        if missing_columns:
            st.error(f"‚ùå Áº∫Â∞ëÂøÖË¶ÅÂàó: {missing_columns}")
            return None
        
        return column_mapping
    
    def validate_data_quality(self, df):
        """Êï∞ÊçÆË¥®ÈáèÈ™åËØÅ"""
        issues = []
        
        # Ê£ÄÊü•ÂøÖË¶ÅÂàó
        required_cols = ['‰ºöÂëòË¥¶Âè∑', 'ÂΩ©Áßç', 'ÊúüÂè∑', 'Áé©Ê≥ï', 'ÂÜÖÂÆπ']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            issues.append(f"Áº∫Â∞ëÂøÖË¶ÅÂàó: {missing_cols}")
        
        # Ê£ÄÊü•Á©∫ÂÄº
        for col in required_cols:
            if col in df.columns:
                null_count = df[col].isnull().sum()
                if null_count > 0:
                    issues.append(f"Âàó '{col}' Êúâ {null_count} ‰∏™Á©∫ÂÄº")

        # Ê£ÄÊü•ÈáçÂ§çÊï∞ÊçÆ
        duplicate_count = df.duplicated().sum()
        if duplicate_count > 0:
            issues.append(f"ÂèëÁé∞ {duplicate_count} Êù°ÈáçÂ§çËÆ∞ÂΩï")
        
        if issues:
            with st.expander("‚ö†Ô∏è Êï∞ÊçÆË¥®ÈáèÈóÆÈ¢ò", expanded=True):
                for issue in issues:
                    st.warning(f"  - {issue}")
        else:
            st.success("‚úÖ Êï∞ÊçÆË¥®ÈáèÊ£ÄÊü•ÈÄöËøá")
        
        return issues

    def normalize_position(self, play_method):
        """Áªü‰∏Ä‰ΩçÁΩÆÂêçÁß∞ - Â¢ûÂº∫Ê≠£Á†ÅÁâπ‰ΩçÁΩÆËØÜÂà´"""
        play_str = str(play_method).strip()
        
        # ========== ÊúÄÈ´ò‰ºòÂÖàÁ∫ßÔºöÊ≠£ÁéõÁâπÁã¨Á´ãÊò†Â∞Ñ ==========
        if 'Ê≠£ÁéõÁâπ' in play_str:
            if 'Ê≠£‰∏Ä' in play_str or 'Ê≠£1' in play_str:
                return 'Ê≠£‰∏ÄÁâπ'
            elif 'Ê≠£‰∫å' in play_str or 'Ê≠£2' in play_str:
                return 'Ê≠£‰∫åÁâπ'
            elif 'Ê≠£‰∏â' in play_str or 'Ê≠£3' in play_str:
                return 'Ê≠£‰∏âÁâπ'
            elif 'Ê≠£Âõõ' in play_str or 'Ê≠£4' in play_str:
                return 'Ê≠£ÂõõÁâπ'
            elif 'Ê≠£‰∫î' in play_str or 'Ê≠£5' in play_str:
                return 'Ê≠£‰∫îÁâπ'
            elif 'Ê≠£ÂÖ≠' in play_str or 'Ê≠£6' in play_str:
                return 'Ê≠£ÂÖ≠Áâπ'
            else:
                return 'Ê≠£Áâπ'
        
        # ========== Êñ∞Â¢ûÔºöÊ≠£Á†ÅÁâπÁã¨Á´ãÊò†Â∞Ñ ==========
        if 'Ê≠£Á†ÅÁâπ' in play_str:
            if 'Ê≠£‰∏Ä' in play_str or 'Ê≠£1' in play_str:
                return 'Ê≠£‰∏ÄÁâπ'
            elif 'Ê≠£‰∫å' in play_str or 'Ê≠£2' in play_str:
                return 'Ê≠£‰∫åÁâπ'
            elif 'Ê≠£‰∏â' in play_str or 'Ê≠£3' in play_str:
                return 'Ê≠£‰∏âÁâπ'
            elif 'Ê≠£Âõõ' in play_str or 'Ê≠£4' in play_str:
                return 'Ê≠£ÂõõÁâπ'
            elif 'Ê≠£‰∫î' in play_str or 'Ê≠£5' in play_str:
                return 'Ê≠£‰∫îÁâπ'
            elif 'Ê≠£ÂÖ≠' in play_str or 'Ê≠£6' in play_str:
                return 'Ê≠£ÂÖ≠Áâπ'
            else:
                return 'Ê≠£Áâπ'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†Å1-6 Ê≠£Á†Å -> Ê≠£Á†Å
        if play_str == 'Ê≠£Á†Å1-6 Ê≠£Á†Å':
            return 'Ê≠£Á†Å'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†Å1-6_Ê≠£Á†Å -> Ê≠£Á†Å
        if play_str == 'Ê≠£Á†Å1-6_Ê≠£Á†Å':
            return 'Ê≠£Á†Å'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†ÅÁâπ_Ê≠£‰∫îÁâπ -> Ê≠£‰∫îÁâπ
        if 'Ê≠£Á†ÅÁâπ_Ê≠£‰∫îÁâπ' in play_str or 'Ê≠£ÁéõÁâπ_Ê≠£‰∫îÁâπ' in play_str:
            return 'Ê≠£‰∫îÁâπ'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†Å1-6_Ê≠£Á†Å‰∏Ä -> Ê≠£Á†Å‰∏Ä
        if 'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∏Ä' in play_str:
            return 'Ê≠£Á†Å‰∏Ä'
        
        # Áõ¥Êé•Êò†Â∞Ñ
        for standard_pos, variants in self.position_mapping.items():
            if play_str in variants:
                return standard_pos
        
        # ÂÖ≥ÈîÆËØçÂåπÈÖç
        for standard_pos, variants in self.position_mapping.items():
            for variant in variants:
                if variant in play_str:
                    return standard_pos
        
        # Êô∫ËÉΩÂåπÈÖç - ÂÖ≠ÂêàÂΩ©Ê≠£Á†Å
        play_lower = play_str.lower()
        if 'Ê≠£Á†Å‰∏Ä' in play_lower or 'Ê≠£Á†Å1' in play_lower or 'Ê≠£‰∏ÄÁ†Å' in play_lower:
            return 'Ê≠£Á†Å‰∏Ä'
        elif 'Ê≠£Á†Å‰∫å' in play_lower or 'Ê≠£Á†Å2' in play_lower or 'Ê≠£‰∫åÁ†Å' in play_lower:
            return 'Ê≠£Á†Å‰∫å'
        elif 'Ê≠£Á†Å‰∏â' in play_lower or 'Ê≠£Á†Å3' in play_lower or 'Ê≠£‰∏âÁ†Å' in play_lower:
            return 'Ê≠£Á†Å‰∏â'
        elif 'Ê≠£Á†ÅÂõõ' in play_lower or 'Ê≠£Á†Å4' in play_lower or 'Ê≠£ÂõõÁ†Å' in play_lower:
            return 'Ê≠£Á†ÅÂõõ'
        elif 'Ê≠£Á†Å‰∫î' in play_lower or 'Ê≠£Á†Å5' in play_lower or 'Ê≠£‰∫îÁ†Å' in play_lower:
            return 'Ê≠£Á†Å‰∫î'
        elif 'Ê≠£Á†ÅÂÖ≠' in play_lower or 'Ê≠£Á†Å6' in play_lower or 'Ê≠£ÂÖ≠Á†Å' in play_lower:
            return 'Ê≠£Á†ÅÂÖ≠'
        
        # Êô∫ËÉΩÂåπÈÖç - ÂÖ≠ÂêàÂΩ©Ê≠£Áâπ
        elif 'Ê≠£‰∏ÄÁâπ' in play_lower or 'Ê≠£1Áâπ' in play_lower:
            return 'Ê≠£‰∏ÄÁâπ'
        elif 'Ê≠£‰∫åÁâπ' in play_lower or 'Ê≠£2Áâπ' in play_lower:
            return 'Ê≠£‰∫åÁâπ'
        elif 'Ê≠£‰∏âÁâπ' in play_lower or 'Ê≠£3Áâπ' in play_lower:
            return 'Ê≠£‰∏âÁâπ'
        elif 'Ê≠£ÂõõÁâπ' in play_lower or 'Ê≠£4Áâπ' in play_lower:
            return 'Ê≠£ÂõõÁâπ'
        elif 'Ê≠£‰∫îÁâπ' in play_lower or 'Ê≠£5Áâπ' in play_lower:
            return 'Ê≠£‰∫îÁâπ'
        elif 'Ê≠£ÂÖ≠Áâπ' in play_lower or 'Ê≠£6Áâπ' in play_lower:
            return 'Ê≠£ÂÖ≠Áâπ'
        
        # Êô∫ËÉΩÂåπÈÖç - ÂÖ≠ÂêàÂΩ©ÂÖ∂‰ªñ
        elif 'Âπ≥Á†Å' in play_lower:
            return 'Âπ≥Á†Å'
        elif 'Âπ≥Áâπ' in play_lower:
            return 'Âπ≥Áâπ'
        elif 'ÁâπÁ†Å' in play_lower or 'ÁâπÁéõ' in play_lower or 'ÁâπÈ©¨' in play_lower or 'ÁâπÁ¢º' in play_lower:
            return 'ÁâπÁ†Å'
        
        # Êô∫ËÉΩÂåπÈÖç - PK10/ËµõËΩ¶
        elif 'ÂÜ†ÂÜõ' in play_lower or 'Á¨¨‰∏ÄÂêç' in play_lower or '1st' in play_lower:
            return 'ÂÜ†ÂÜõ'
        elif '‰∫öÂÜõ' in play_lower or 'Á¨¨‰∫åÂêç' in play_lower or '2nd' in play_lower:
            return '‰∫öÂÜõ'
        elif 'Â≠£ÂÜõ' in play_lower or 'Á¨¨‰∏âÂêç' in play_lower or '3rd' in play_lower:
            return 'Â≠£ÂÜõ'
        elif 'Á¨¨ÂõõÂêç' in play_lower or 'Á¨¨Âõõ‰Ωç' in play_lower or '4th' in play_lower:
            return 'Á¨¨ÂõõÂêç'
        elif 'Á¨¨‰∫îÂêç' in play_lower or 'Á¨¨‰∫î‰Ωç' in play_lower or '5th' in play_lower:
            return 'Á¨¨‰∫îÂêç'
        elif 'Á¨¨ÂÖ≠Âêç' in play_lower or 'Á¨¨ÂÖ≠‰Ωç' in play_lower or '6th' in play_lower:
            return 'Á¨¨ÂÖ≠Âêç'
        elif 'Á¨¨‰∏ÉÂêç' in play_lower or 'Á¨¨‰∏É‰Ωç' in play_lower or '7th' in play_lower:
            return 'Á¨¨‰∏ÉÂêç'
        elif 'Á¨¨ÂÖ´Âêç' in play_lower or 'Á¨¨ÂÖ´‰Ωç' in play_lower or '8th' in play_lower:
            return 'Á¨¨ÂÖ´Âêç'
        elif 'Á¨¨‰πùÂêç' in play_lower or 'Á¨¨‰πù‰Ωç' in play_lower or '9th' in play_lower:
            return 'Á¨¨‰πùÂêç'
        elif 'Á¨¨ÂçÅÂêç' in play_lower or 'Á¨¨ÂçÅ‰Ωç' in play_lower or '10th' in play_lower:
            return 'Á¨¨ÂçÅÂêç'
        elif 'Ââç‰∏Ä' in play_lower or 'Ââç‰∏Ä‰Ωç' in play_lower or 'Á¨¨‰∏Ä‰Ωç' in play_lower:
            return 'Ââç‰∏Ä'
        
        # Êô∫ËÉΩÂåπÈÖç - Âø´‰∏â
        elif 'ÂíåÂÄº' in play_lower or 'ÂíåÊï∞' in play_lower or 'Âíå' in play_lower:
            return 'ÂíåÂÄº'
        
        return play_str

    def enhanced_normalize_special_characters(self, text):
        """Â¢ûÂº∫ÁâπÊÆäÂ≠óÁ¨¶Â§ÑÁêÜ"""
        if not text:
            return text

        import re
        text = re.sub(r'\s+', ' ', text)
        text = text.strip()
        
        return text

    def enhanced_extract_position_from_content(self, play_method, content, lottery_category):
        """‰ªéÂÜÖÂÆπ‰∏≠ÊèêÂèñÂÖ∑‰Ωì‰ΩçÁΩÆ‰ø°ÊÅØ - ÈíàÂØπÂÆö‰ΩçËÉÜÁ≠âÂ§çÂêàÁé©Ê≥ï"""
        play_str = str(play_method).strip()
        content_str = str(content).strip()
        
        # üÜï Â¢ûÂº∫ÂÆö‰ΩçËÉÜÁé©Ê≥ïËØÜÂà´
        if play_str == 'ÂÆö‰ΩçËÉÜ' and (':' in content_str or 'Ôºö' in content_str):
            # ÊèêÂèñ‰ΩçÁΩÆ‰ø°ÊÅØÔºàÂ¶Ç"‰∫öÂÜõ:03,04,05"‰∏≠ÁöÑ"‰∫öÂÜõ"Ôºâ
            position_match = re.match(r'^([^:Ôºö]+)[:Ôºö]', content_str)
            if position_match:
                position = position_match.group(1).strip()
                
                # üÜï Â¢ûÂº∫‰ΩçÁΩÆÂêçÁß∞Êò†Â∞Ñ
                position_mapping = {
                    'ÂÜ†ÂÜõ': 'ÂÜ†ÂÜõ', '‰∫öÂÜõ': '‰∫öÂÜõ', 'Â≠£ÂÜõ': 'Â≠£ÂÜõ',
                    'Á¨¨ÂõõÂêç': 'Á¨¨ÂõõÂêç', 'Á¨¨‰∫îÂêç': 'Á¨¨‰∫îÂêç', 'Á¨¨ÂÖ≠Âêç': 'Á¨¨ÂÖ≠Âêç',
                    'Á¨¨‰∏ÉÂêç': 'Á¨¨‰∏ÉÂêç', 'Á¨¨ÂÖ´Âêç': 'Á¨¨ÂÖ´Âêç', 'Á¨¨‰πùÂêç': 'Á¨¨‰πùÂêç', 'Á¨¨ÂçÅÂêç': 'Á¨¨ÂçÅÂêç',
                    'Á¨¨1Âêç': 'ÂÜ†ÂÜõ', 'Á¨¨2Âêç': '‰∫öÂÜõ', 'Á¨¨3Âêç': 'Â≠£ÂÜõ',
                    'Á¨¨4Âêç': 'Á¨¨ÂõõÂêç', 'Á¨¨5Âêç': 'Á¨¨‰∫îÂêç', 'Á¨¨6Âêç': 'Á¨¨ÂÖ≠Âêç',
                    'Á¨¨7Âêç': 'Á¨¨‰∏ÉÂêç', 'Á¨¨8Âêç': 'Á¨¨ÂÖ´Âêç', 'Á¨¨9Âêç': 'Á¨¨‰πùÂêç', 'Á¨¨10Âêç': 'Á¨¨ÂçÅÂêç',
                    'Á¨¨‰∏ÄÂêç': 'ÂÜ†ÂÜõ', 'Á¨¨‰∫åÂêç': '‰∫öÂÜõ', 'Á¨¨‰∏âÂêç': 'Â≠£ÂÜõ',
                    'Á¨¨Âõõ‰Ωç': 'Á¨¨ÂõõÂêç', 'Á¨¨‰∫î‰Ωç': 'Á¨¨‰∫îÂêç', 'Á¨¨ÂÖ≠‰Ωç': 'Á¨¨ÂÖ≠Âêç',
                    'Á¨¨‰∏É‰Ωç': 'Á¨¨‰∏ÉÂêç', 'Á¨¨ÂÖ´‰Ωç': 'Á¨¨ÂÖ´Âêç', 'Á¨¨‰πù‰Ωç': 'Á¨¨‰πùÂêç', 'Á¨¨ÂçÅ‰Ωç': 'Á¨¨ÂçÅÂêç',
                    '1st': 'ÂÜ†ÂÜõ', '2nd': '‰∫öÂÜõ', '3rd': 'Â≠£ÂÜõ', '4th': 'Á¨¨ÂõõÂêç', '5th': 'Á¨¨‰∫îÂêç',
                    '6th': 'Á¨¨ÂÖ≠Âêç', '7th': 'Á¨¨‰∏ÉÂêç', '8th': 'Á¨¨ÂÖ´Âêç', '9th': 'Á¨¨‰πùÂêç', '10th': 'Á¨¨ÂçÅÂêç',
                    'Ââç‰∏Ä': 'ÂÜ†ÂÜõ', 'Ââç‰∫å': '‰∫öÂÜõ', 'Ââç‰∏â': 'Â≠£ÂÜõ',
                    # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÂèØËÉΩÁöÑÁ©∫Ê†ºÂíåÊ†ºÂºèÂèò‰Ωì
                    'ÂÜ† ÂÜõ': 'ÂÜ†ÂÜõ', '‰∫ö ÂÜõ': '‰∫öÂÜõ', 'Â≠£ ÂÜõ': 'Â≠£ÂÜõ',
                    'ÂÜ†„ÄÄÂÜõ': 'ÂÜ†ÂÜõ', '‰∫ö„ÄÄÂÜõ': '‰∫öÂÜõ', 'Â≠£„ÄÄÂÜõ': 'Â≠£ÂÜõ',
                    # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÊï∞Â≠óÊ†ºÂºè
                    'Á¨¨ 1 Âêç': 'ÂÜ†ÂÜõ', 'Á¨¨ 2 Âêç': '‰∫öÂÜõ', 'Á¨¨ 3 Âêç': 'Â≠£ÂÜõ',
                    'Á¨¨1 Âêç': 'ÂÜ†ÂÜõ', 'Á¨¨2 Âêç': '‰∫öÂÜõ', 'Á¨¨3 Âêç': 'Â≠£ÂÜõ',
                }
                
                normalized_position = position_mapping.get(position, position)
                return normalized_position
        
        # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÊ≤°ÊúâÂÜíÂè∑‰ΩÜÂÜÖÂÆπÊòéÁ°ÆÂåÖÂê´‰ΩçÁΩÆÂêçÁß∞ÁöÑÊÉÖÂÜµ
        if play_str == 'ÂÆö‰ΩçËÉÜ':
            content_lower = content_str.lower()
            position_keywords = {
                'ÂÜ†ÂÜõ': ['ÂÜ†ÂÜõ', 'Á¨¨‰∏ÄÂêç', 'Á¨¨1Âêç', '1st', 'Ââç‰∏Ä'],
                '‰∫öÂÜõ': ['‰∫öÂÜõ', 'Á¨¨‰∫åÂêç', 'Á¨¨2Âêç', '2nd'],
                'Â≠£ÂÜõ': ['Â≠£ÂÜõ', 'Á¨¨‰∏âÂêç', 'Á¨¨3Âêç', '3rd'],
                'Á¨¨ÂõõÂêç': ['Á¨¨ÂõõÂêç', 'Á¨¨4Âêç', '4th'],
                'Á¨¨‰∫îÂêç': ['Á¨¨‰∫îÂêç', 'Á¨¨5Âêç', '5th'],
                'Á¨¨ÂÖ≠Âêç': ['Á¨¨ÂÖ≠Âêç', 'Á¨¨6Âêç', '6th'],
                'Á¨¨‰∏ÉÂêç': ['Á¨¨‰∏ÉÂêç', 'Á¨¨7Âêç', '7th'],
                'Á¨¨ÂÖ´Âêç': ['Á¨¨ÂÖ´Âêç', 'Á¨¨8Âêç', '8th'],
                'Á¨¨‰πùÂêç': ['Á¨¨‰πùÂêç', 'Á¨¨9Âêç', '9th'],
                'Á¨¨ÂçÅÂêç': ['Á¨¨ÂçÅÂêç', 'Á¨¨10Âêç', '10th']
            }
            
            for position, keywords in position_keywords.items():
                for keyword in keywords:
                    if keyword in content_lower:
                        return position
        
        return play_str
    
    def normalize_play_category(self, play_method, lottery_category='six_mark'):
        """Áªü‰∏ÄÁé©Ê≥ïÂàÜÁ±ª - Â¢ûÂº∫ÂêÑÁßçÁé©Ê≥ïÁöÑËØÜÂà´"""
        play_str = str(play_method).strip()
        
        # ËßÑËåÉÂåñÁâπÊÆäÂ≠óÁ¨¶
        import re
        play_normalized = re.sub(r'\s+', ' ', play_str)
        
        # ========== ÊúÄÈ´ò‰ºòÂÖàÁ∫ßÔºöÊ≠£ÁéõÁâπÁã¨Á´ãÊò†Â∞Ñ ==========
        if 'Ê≠£ÁéõÁâπ' in play_normalized:
            if 'Ê≠£‰∏Ä' in play_normalized or 'Ê≠£1' in play_normalized:
                return 'Ê≠£‰∏ÄÁâπ'
            elif 'Ê≠£‰∫å' in play_normalized or 'Ê≠£2' in play_normalized:
                return 'Ê≠£‰∫åÁâπ'
            elif 'Ê≠£‰∏â' in play_normalized or 'Ê≠£3' in play_normalized:
                return 'Ê≠£‰∏âÁâπ'
            elif 'Ê≠£Âõõ' in play_normalized or 'Ê≠£4' in play_normalized:
                return 'Ê≠£ÂõõÁâπ'
            elif 'Ê≠£‰∫î' in play_normalized or 'Ê≠£5' in play_normalized:
                return 'Ê≠£‰∫îÁâπ'
            elif 'Ê≠£ÂÖ≠' in play_normalized or 'Ê≠£6' in play_normalized:
                return 'Ê≠£ÂÖ≠Áâπ'
            else:
                return 'Ê≠£Áâπ'
        
        # ========== Êñ∞Â¢ûÔºöÊ≠£Á†ÅÁâπÁã¨Á´ãÊò†Â∞Ñ ==========
        if 'Ê≠£Á†ÅÁâπ' in play_normalized:
            if 'Ê≠£‰∏Ä' in play_normalized or 'Ê≠£1' in play_normalized:
                return 'Ê≠£‰∏ÄÁâπ'
            elif 'Ê≠£‰∫å' in play_normalized or 'Ê≠£2' in play_normalized:
                return 'Ê≠£‰∫åÁâπ'
            elif 'Ê≠£‰∏â' in play_normalized or 'Ê≠£3' in play_normalized:
                return 'Ê≠£‰∏âÁâπ'
            elif 'Ê≠£Âõõ' in play_normalized or 'Ê≠£4' in play_normalized:
                return 'Ê≠£ÂõõÁâπ'
            elif 'Ê≠£‰∫î' in play_normalized or 'Ê≠£5' in play_normalized:
                return 'Ê≠£‰∫îÁâπ'
            elif 'Ê≠£ÂÖ≠' in play_normalized or 'Ê≠£6' in play_normalized:
                return 'Ê≠£ÂÖ≠Áâπ'
            else:
                return 'Ê≠£Áâπ'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†Å1-6 Ê≠£Á†Å -> Ê≠£Á†Å
        if play_normalized == 'Ê≠£Á†Å1-6 Ê≠£Á†Å':
            return 'Ê≠£Á†Å'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†Å1-6_Ê≠£Á†Å -> Ê≠£Á†Å  
        if play_normalized == 'Ê≠£Á†Å1-6_Ê≠£Á†Å':
            return 'Ê≠£Á†Å'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†ÅÁâπ_Ê≠£‰∫îÁâπ -> Ê≠£5Áâπ
        if 'Ê≠£Á†ÅÁâπ_Ê≠£‰∫îÁâπ' in play_normalized or 'Ê≠£ÁéõÁâπ_Ê≠£‰∫îÁâπ' in play_normalized:
            return 'Ê≠£‰∫îÁâπ'
        
        # ÁâπÊÆäÂ§ÑÁêÜÔºöÊ≠£Á†Å1-6_Ê≠£Á†Å‰∏Ä -> Ê≠£Á†Å‰∏Ä
        if 'Ê≠£Á†Å1-6_Ê≠£Á†Å‰∏Ä' in play_normalized:
            return 'Ê≠£Á†Å‰∏Ä'
        
        # 1. Áõ¥Êé•Êò†Â∞ÑÔºàÂÆåÂÖ®ÂåπÈÖçÔºâ
        if play_normalized in self.play_mapping:
            return self.play_mapping[play_normalized]
        
        # 2. ÂÖ≥ÈîÆËØçÂåπÈÖçÔºàÂåÖÂê´ÂåπÈÖçÔºâ
        for key, value in self.play_mapping.items():
            if key in play_normalized:
                return value
        
        # 3. Â§ÑÁêÜÁâπÊÆäÊ†ºÂºèÔºà‰∏ãÂàíÁ∫ø„ÄÅËøûÂ≠óÁ¨¶ÂàÜÈöîÔºâ
        if '_' in play_normalized or '-' in play_normalized:
            parts = re.split(r'[_-]', play_normalized)
            if len(parts) >= 2:
                main_play = parts[0].strip()
                sub_play = parts[1].strip()
                
                # Â§ÑÁêÜÊ≠£Á†ÅÁâπÂíåÊ≠£ÁéõÁâπÊ†ºÂºè
                if 'Ê≠£Á†ÅÁâπ' in main_play or 'Ê≠£ÁéõÁâπ' in main_play:  # ÂÖ≥ÈîÆ‰øÆÂ§ç
                    if 'Ê≠£‰∏Ä' in sub_play or 'Ê≠£1' in sub_play:
                        return 'Ê≠£1Áâπ'
                    elif 'Ê≠£‰∫å' in sub_play or 'Ê≠£2' in sub_play:
                        return 'Ê≠£2Áâπ'
                    elif 'Ê≠£‰∏â' in sub_play or 'Ê≠£3' in sub_play:
                        return 'Ê≠£3Áâπ'
                    elif 'Ê≠£Âõõ' in sub_play or 'Ê≠£4' in sub_play:
                        return 'Ê≠£4Áâπ'
                    elif 'Ê≠£‰∫î' in sub_play or 'Ê≠£5' in sub_play:
                        return 'Ê≠£5Áâπ'
                    elif 'Ê≠£ÂÖ≠' in sub_play or 'Ê≠£6' in sub_play:
                        return 'Ê≠£6Áâπ'
                    else:
                        return 'Ê≠£Áâπ'
        
        # 4. Ê†πÊçÆÂΩ©ÁßçÁ±ªÂûãÊô∫ËÉΩÂåπÈÖç
        play_lower = play_normalized.lower()
        
        if lottery_category == 'six_mark':
            # ÂÖ≠ÂêàÂΩ©Âè∑Á†ÅÁé©Ê≥ïÊô∫ËÉΩÂåπÈÖç - Â¢ûÂº∫Ê≠£ÁéõÁâπËØÜÂà´
            if any(word in play_lower for word in ['ÁâπÁ†Å', 'ÁâπÁéõ', 'ÁâπÈ©¨', 'ÁâπÁ¢º']):
                return 'ÁâπÁ†Å'
            elif any(word in play_lower for word in ['Ê≠£Á†Å‰∏Ä', 'Ê≠£Á†Å1', 'Ê≠£‰∏ÄÁ†Å']):
                return 'Ê≠£Á†Å‰∏Ä'
            elif any(word in play_lower for word in ['Ê≠£Á†Å‰∫å', 'Ê≠£Á†Å2', 'Ê≠£‰∫åÁ†Å']):
                return 'Ê≠£Á†Å‰∫å'
            elif any(word in play_lower for word in ['Ê≠£Á†Å‰∏â', 'Ê≠£Á†Å3', 'Ê≠£‰∏âÁ†Å']):
                return 'Ê≠£Á†Å‰∏â'
            elif any(word in play_lower for word in ['Ê≠£Á†ÅÂõõ', 'Ê≠£Á†Å4', 'Ê≠£ÂõõÁ†Å']):
                return 'Ê≠£Á†ÅÂõõ'
            elif any(word in play_lower for word in ['Ê≠£Á†Å‰∫î', 'Ê≠£Á†Å5', 'Ê≠£‰∫îÁ†Å']):
                return 'Ê≠£Á†Å‰∫î'
            elif any(word in play_lower for word in ['Ê≠£Á†ÅÂÖ≠', 'Ê≠£Á†Å6', 'Ê≠£ÂÖ≠Á†Å']):
                return 'Ê≠£Á†ÅÂÖ≠'
            elif any(word in play_lower for word in ['Ê≠£‰∏ÄÁâπ', 'Ê≠£1Áâπ']):
                return 'Ê≠£1Áâπ'
            elif any(word in play_lower for word in ['Ê≠£‰∫åÁâπ', 'Ê≠£2Áâπ']):
                return 'Ê≠£2Áâπ'
            elif any(word in play_lower for word in ['Ê≠£‰∏âÁâπ', 'Ê≠£3Áâπ']):
                return 'Ê≠£3Áâπ'
            elif any(word in play_lower for word in ['Ê≠£ÂõõÁâπ', 'Ê≠£4Áâπ']):
                return 'Ê≠£4Áâπ'
            elif any(word in play_lower for word in ['Ê≠£‰∫îÁâπ', 'Ê≠£5Áâπ']):
                return 'Ê≠£5Áâπ'
            elif any(word in play_lower for word in ['Ê≠£ÂÖ≠Áâπ', 'Ê≠£6Áâπ']):
                return 'Ê≠£6Áâπ'
            # üÜï ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂ¢ûÂº∫Â∞æÊï∞Áé©Ê≥ïËØÜÂà´
            elif any(word in play_lower for word in ['Â∞æÊï∞']):
                return 'Â∞æÊï∞'
            elif any(word in play_lower for word in ['ÂÖ®Â∞æ']):
                return 'ÂÖ®Â∞æ'
            elif any(word in play_lower for word in ['ÁâπÂ∞æ']):
                return 'ÁâπÂ∞æ'
            # ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂ¢ûÂº∫Ê≠£ÁéõÁâπËØÜÂà´
            elif any(word in play_lower for word in ['Ê≠£ÁéõÁâπ']):
                # Â¶ÇÊûúÊ≠£ÁéõÁâπÂêéÈù¢ÊúâÂÖ∑‰Ωì‰ΩçÁΩÆ‰ø°ÊÅØ
                if 'Ê≠£‰∏Ä' in play_lower or 'Ê≠£1' in play_lower:
                    return 'Ê≠£1Áâπ'
                elif 'Ê≠£‰∫å' in play_lower or 'Ê≠£2' in play_lower:
                    return 'Ê≠£2Áâπ'
                elif 'Ê≠£‰∏â' in play_lower or 'Ê≠£3' in play_lower:
                    return 'Ê≠£3Áâπ'
                elif 'Ê≠£Âõõ' in play_lower or 'Ê≠£4' in play_lower:
                    return 'Ê≠£4Áâπ'
                elif 'Ê≠£‰∫î' in play_lower or 'Ê≠£5' in play_lower:
                    return 'Ê≠£5Áâπ'
                elif 'Ê≠£ÂÖ≠' in play_lower or 'Ê≠£6' in play_lower:
                    return 'Ê≠£6Áâπ'
                else:
                    return 'Ê≠£Áâπ'
            elif any(word in play_lower for word in ['Ê≠£Áâπ', 'Ê≠£Á†ÅÁâπ']):
                return 'Ê≠£Áâπ'
            elif any(word in play_lower for word in ['Âπ≥Á†Å']):
                return 'Âπ≥Á†Å'
            elif any(word in play_lower for word in ['Âπ≥Áâπ']):
                return 'Âπ≥Áâπ'
            
        elif lottery_category == '10_number':
            # Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶Âè∑Á†ÅÁé©Ê≥ïÊô∫ËÉΩÂåπÈÖç
            if any(word in play_lower for word in ['ÂÜ†ÂÜõ', 'Á¨¨‰∏ÄÂêç', 'Á¨¨1Âêç', '1st', 'Ââç‰∏Ä']):
                return 'ÂÜ†ÂÜõ'
            elif any(word in play_lower for word in ['‰∫öÂÜõ', 'Á¨¨‰∫åÂêç', 'Á¨¨2Âêç', '2nd']):
                return '‰∫öÂÜõ'
            elif any(word in play_lower for word in ['Â≠£ÂÜõ', 'Á¨¨‰∏âÂêç', 'Á¨¨3Âêç', '3rd']):
                return 'Â≠£ÂÜõ'
            elif any(word in play_lower for word in ['Á¨¨ÂõõÂêç', 'Á¨¨4Âêç', '4th']):
                return 'Á¨¨ÂõõÂêç'
            elif any(word in play_lower for word in ['Á¨¨‰∫îÂêç', 'Á¨¨5Âêç', '5th']):
                return 'Á¨¨‰∫îÂêç'
            elif any(word in play_lower for word in ['Á¨¨ÂÖ≠Âêç', 'Á¨¨6Âêç', '6th']):
                return 'Á¨¨ÂÖ≠Âêç'
            elif any(word in play_lower for word in ['Á¨¨‰∏ÉÂêç', 'Á¨¨7Âêç', '7th']):
                return 'Á¨¨‰∏ÉÂêç'
            elif any(word in play_lower for word in ['Á¨¨ÂÖ´Âêç', 'Á¨¨8Âêç', '8th']):
                return 'Á¨¨ÂÖ´Âêç'
            elif any(word in play_lower for word in ['Á¨¨‰πùÂêç', 'Á¨¨9Âêç', '9th']):
                return 'Á¨¨‰πùÂêç'
            elif any(word in play_lower for word in ['Á¨¨ÂçÅÂêç', 'Á¨¨10Âêç', '10th']):
                return 'Á¨¨ÂçÅÂêç'
            elif any(word in play_lower for word in ['‰∏á‰Ωç', 'Á¨¨‰∏Ä‰Ωç', 'Á¨¨‰∏ÄÁêÉ']):
                return 'Á¨¨1ÁêÉ'
            elif any(word in play_lower for word in ['ÂçÉ‰Ωç', 'Á¨¨‰∫å‰Ωç', 'Á¨¨‰∫åÁêÉ']):
                return 'Á¨¨2ÁêÉ'
            elif any(word in play_lower for word in ['Áôæ‰Ωç', 'Á¨¨‰∏â‰Ωç', 'Á¨¨‰∏âÁêÉ']):
                return 'Á¨¨3ÁêÉ'
            elif any(word in play_lower for word in ['ÂçÅ‰Ωç', 'Á¨¨Âõõ‰Ωç', 'Á¨¨ÂõõÁêÉ']):
                return 'Á¨¨4ÁêÉ'
            elif any(word in play_lower for word in ['‰∏™‰Ωç', 'Á¨¨‰∫î‰Ωç', 'Á¨¨‰∫îÁêÉ']):
                return 'Á¨¨5ÁêÉ'
            elif any(word in play_lower for word in ['ÂÆö‰ΩçËÉÜ', '‰∏ÄÂ≠óÂÆö‰Ωç', '‰∏ÄÂ≠ó', 'ÂÆö‰Ωç']):
                return 'ÂÆö‰ΩçËÉÜ'
            elif any(word in play_lower for word in ['1-5Âêç', '1~5Âêç']):
                return '1-5Âêç'
            elif any(word in play_lower for word in ['6-10Âêç', '6~10Âêç']):
                return '6-10Âêç'
            elif any(word in play_lower for word in ['ÂÜ†‰∫öÂíå', 'ÂÜ†‰∫öÂíåÂÄº']):
                return 'ÂÜ†‰∫öÂíå'
        
        elif lottery_category == 'fast_three':
            # Âø´‰∏âÂè∑Á†ÅÁé©Ê≥ïÊô∫ËÉΩÂåπÈÖç
            if any(word in play_lower for word in ['ÂíåÂÄº', 'ÂíåÊï∞', 'Âíå']):
                return 'ÂíåÂÄº'
            elif any(word in play_lower for word in ['‰∏âÂÜõ', 'Áã¨ËÉÜ', 'ÂçïÁ†Å']):
                return '‰∏âÂÜõ'
            elif any(word in play_lower for word in ['‰∫å‰∏çÂêåÂè∑', '‰∫å‰∏çÂêå']):
                return '‰∫å‰∏çÂêåÂè∑'
            elif any(word in play_lower for word in ['‰∏â‰∏çÂêåÂè∑', '‰∏â‰∏çÂêå']):
                return '‰∏â‰∏çÂêåÂè∑'
        
        elif lottery_category == '3d_series':
            # 3DÁ≥ªÂàóÂè∑Á†ÅÁé©Ê≥ïÊô∫ËÉΩÂåπÈÖç
            if any(word in play_lower for word in ['Áôæ‰Ωç']):
                return 'Áôæ‰Ωç'
            elif any(word in play_lower for word in ['ÂçÅ‰Ωç']):
                return 'ÂçÅ‰Ωç'
            elif any(word in play_lower for word in ['‰∏™‰Ωç']):
                return '‰∏™‰Ωç'
            elif any(word in play_lower for word in ['ÁôæÂçÅ']):
                return 'ÁôæÂçÅ'
            elif any(word in play_lower for word in ['Áôæ‰∏™']):
                return 'Áôæ‰∏™'
            elif any(word in play_lower for word in ['ÂçÅ‰∏™']):
                return 'ÂçÅ‰∏™'
            elif any(word in play_lower for word in ['ÁôæÂçÅ‰∏™']):
                return 'ÁôæÂçÅ‰∏™'
        
        # 5. ÈÄöÁî®Âè∑Á†ÅÁé©Ê≥ïÂåπÈÖç
        if any(word in play_lower for word in ['ÊÄªÂíå']):
            return 'ÊÄªÂíå'
        elif any(word in play_lower for word in ['ÊñóÁâõ']):
            return 'ÊñóÁâõ'
        
        return play_normalized
    
    @lru_cache(maxsize=5000)
    def cached_extract_numbers(self, content, lottery_category, play_method=None):
        """Â∏¶ÁºìÂ≠òÁöÑÂè∑Á†ÅÊèêÂèñ - ‰øÆÂ§çÁâàÊú¨ÔºåÊîØÊåÅÁé©Ê≥ïÂèÇÊï∞"""
        content_str = str(content) if content else ""
        return self.enhanced_extract_numbers(content_str, lottery_category, play_method)
    
    def enhanced_extract_numbers(self, content, lottery_category='six_mark', play_method=None):
        """Â¢ûÂº∫Âè∑Á†ÅÊèêÂèñ - ‰∏ìÈó®Â§ÑÁêÜÂÆö‰ΩçËÉÜÊ†ºÂºèÂíåÂ∞æÊï∞Ê†ºÂºè"""
        content_str = str(content).strip()
        numbers = []
        
        try:
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÁ©∫ÂÜÖÂÆπ
            if not content_str or content_str.lower() in ['', 'null', 'none', 'nan']:
                return []
            
            # üÜï ‰øÆÊ≠£ÔºöÊ†πÊçÆÁé©Ê≥ïÁ°ÆÂÆöÂÖ∑‰ΩìÁöÑÈÖçÁΩÆ
            config = self.get_play_specific_config(lottery_category, play_method)
            number_range = config['number_range']
            
            # üÜï Â¢ûÂº∫ÔºöÂ§ÑÁêÜÂ∞æÊï∞ÁâπÊÆäÊ†ºÂºèÔºàÊúÄÈ´ò‰ºòÂÖàÁ∫ßÔºâ
            play_str = str(play_method).strip().lower() if play_method else ""
            if any(keyword in play_str for keyword in ['Â∞æÊï∞', 'ÂÖ®Â∞æ', 'ÁâπÂ∞æ']):
                print(f"üîç Ë∞ÉËØïÂ∞æÊï∞ÊèêÂèñ: Áé©Ê≥ï='{play_str}', ÂÜÖÂÆπ='{content_str}'")
                
                # Â§ÑÁêÜ "ÂÖ®Â∞æ-8Â∞æ,9Â∞æ,7Â∞æ,6Â∞æ,5Â∞æ" ËøôÁßçÊ†ºÂºè
                if 'ÂÖ®Â∞æ-' in content_str:
                    # ÊèêÂèñÂè∑Á†ÅÈÉ®ÂàÜ
                    tail_part = content_str.split('ÂÖ®Â∞æ-')[1].strip()
                    # ÁßªÈô§ÊâÄÊúâ"Â∞æ"Â≠óÔºåÁÑ∂ÂêéÊèêÂèñÊï∞Â≠ó
                    clean_tail = tail_part.replace('Â∞æ', '')
                    tail_numbers = re.findall(r'\d', clean_tail)
                    for num_str in tail_numbers:
                        num = int(num_str)
                        if num in number_range:
                            numbers.append(num)
                    if numbers:
                        print(f"‚úÖ Â∞æÊï∞ÊèêÂèñÁªìÊûú1: {numbers}")
                        return list(set(numbers))
                
                # Â§ÑÁêÜ "ÂÖ®Â∞æ-1Â∞æ,2Â∞æ,3Â∞æ,4Â∞æ,0Â∞æ" ËøôÁßçÊ†ºÂºè
                if 'ÂÖ®Â∞æ' in content_str and 'Â∞æ' in content_str:
                    # Áõ¥Êé•ÊèêÂèñÊâÄÊúâ"XÂ∞æ"Ê†ºÂºèÁöÑÊï∞Â≠ó
                    tail_matches = re.findall(r'(\d)Â∞æ', content_str)
                    for num_str in tail_matches:
                        num = int(num_str)
                        if num in number_range:
                            numbers.append(num)
                    if numbers:
                        print(f"‚úÖ Â∞æÊï∞ÊèêÂèñÁªìÊûú2: {numbers}")
                        return list(set(numbers))
                
                # Â§ÑÁêÜÁÆÄÂçïÁöÑÈÄóÂè∑ÂàÜÈöîÊ†ºÂºè
                if ',' in content_str:
                    parts = content_str.split(',')
                    for part in parts:
                        part_clean = part.strip()
                        # ÊèêÂèñÊï∞Â≠ó
                        num_matches = re.findall(r'\d', part_clean)
                        for num_str in num_matches:
                            num = int(num_str)
                            if num in number_range:
                                numbers.append(num)
                    if numbers:
                        print(f"‚úÖ Â∞æÊï∞ÊèêÂèñÁªìÊûú3: {numbers}")
                        return list(set(numbers))
            
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÁâπÊÆäÂ≠óÁ¨¶ÂíåÁ©∫ÁôΩ
            content_str = re.sub(r'[\s\u3000]+', ' ', content_str)
            
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÊã¨Âè∑ÂÜÖÁöÑÂÜÖÂÆπ
            content_str = re.sub(r'[\(Ôºà].*?[\)Ôºâ]', '', content_str)
            
            # üÜï Êñ∞Â¢ûÔºö‰∏ìÈó®Â§ÑÁêÜÂÆö‰ΩçËÉÜÊ†ºÂºèÔºà‰ΩçÁΩÆ:Âè∑Á†ÅÔºâ
            if ':' in content_str or 'Ôºö' in content_str:
                colon_patterns = [
                    r'^[^:Ôºö]+[:Ôºö]\s*([\d,\s]+)$',
                    r'^[^:Ôºö]+[:Ôºö]\s*(\d+(?:\s*,\s*\d+)*)$',
                    r'^([^:Ôºö]+)[:Ôºö].*$'
                ]
                
                for pattern in colon_patterns:
                    match = re.match(pattern, content_str)
                    if match:
                        number_part = match.group(1).strip()
                        number_part = re.sub(r'\s+', '', number_part)
                        if number_part:
                            number_strs = number_part.split(',')
                            for num_str in number_strs:
                                if num_str.isdigit():
                                    num = int(num_str)
                                    if num in number_range:
                                        numbers.append(num)
                            if numbers:
                                return list(set(numbers))
            
            # üÜï ‰øÆÂ§çÔºöÂ§ÑÁêÜÂ§öÁßçÂàÜÈöîÁ¨¶Ê†ºÂºè
            separators = [',', 'Ôºå', ' ', ';', 'Ôºõ', '„ÄÅ', '/', '\\', '|']
            
            # È¶ñÂÖàÂ∞ùËØï‰ªéÊï¥‰∏™ÂÜÖÂÆπ‰∏≠ÊèêÂèñÊâÄÊúâÊï∞Â≠ó
            all_number_matches = re.findall(r'\b\d{1,2}\b', content_str)
            if all_number_matches:
                for num_str in all_number_matches:
                    if num_str.isdigit():
                        num = int(num_str)
                        if num in number_range:
                            numbers.append(num)
                if numbers:
                    return list(set(numbers))
            
            # ÁÑ∂ÂêéÂ∞ùËØïÂàÜÈöîÁ¨¶ÊãÜÂàÜ
            for sep in separators:
                if sep in content_str:
                    parts = content_str.split(sep)
                    for part in parts:
                        part_clean = part.strip()
                        number_matches = re.findall(r'\b\d{1,2}\b', part_clean)
                        for num_str in number_matches:
                            if num_str.isdigit():
                                num = int(num_str)
                                if num in number_range:
                                    numbers.append(num)
                    if numbers:
                        break
            
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜËøûÁª≠Êï∞Â≠óÊ†ºÂºè
            if not numbers and re.match(r'^\d{2,}$', content_str.replace(' ', '')):
                clean_content = content_str.replace(' ', '')
                if lottery_category == 'six_mark':
                    for i in range(0, len(clean_content)-1, 2):
                        num_str = clean_content[i:i+2]
                        if num_str.isdigit():
                            num = int(num_str)
                            if 1 <= num <= 49:
                                numbers.append(num)
                elif lottery_category in ['10_number', '3d_series', 'fast_three']:
                    for char in clean_content:
                        if char.isdigit():
                            num = int(char)
                            if num in number_range:
                                numbers.append(num)
            
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜËåÉÂõ¥Ê†ºÂºè
            range_patterns = [
                r'(\d+)\s*[-~ÔΩû]\s*(\d+)',
                r'‰ªé\s*(\d+)\s*Âà∞\s*(\d+)',
                r'(\d+)\s*Ëá≥\s*(\d+)'
            ]
            
            for pattern in range_patterns:
                matches = re.findall(pattern, content_str)
                for start_str, end_str in matches:
                    if start_str.isdigit() and end_str.isdigit():
                        start = int(start_str)
                        end = int(end_str)
                        if start <= end:
                            for num in range(start, end + 1):
                                if num in number_range:
                                    numbers.append(num)
            
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÂè∑Á†Å+ÁâπÊÆäÊ†áËÆ∞
            marked_numbers = re.findall(r'(\d{1,2})[*‚àö‚òÖ‚òÜ‚ô•‚ô¶‚ô£‚ô†]', content_str)
            for num_str in marked_numbers:
                if num_str.isdigit():
                    num = int(num_str)
                    if num in number_range:
                        numbers.append(num)
            
            # üÜï Êñ∞Â¢ûÔºöÂ§ÑÁêÜÂ∏∏ËßÅÈÄóÂè∑ÂàÜÈöîÊ†ºÂºè
            if not numbers and re.match(r'^(\d{1,2},)*\d{1,2}$', content_str):
                new_numbers = [int(x.strip()) for x in content_str.split(',') if x.strip().isdigit()]
                numbers.extend(new_numbers)
            
            # üÜï Êñ∞Â¢ûÔºöÊèêÂèñÊâÄÊúâ1-2‰ΩçÊï∞Â≠ó
            if not numbers:
                number_matches = re.findall(r'\b\d{1,2}\b', content_str)
                for match in number_matches:
                    num = int(match)
                    if num in number_range:
                        numbers.append(num)
            
            # üÜï Êñ∞Â¢ûÔºöÂéªÈáçÂπ∂ÊéíÂ∫è
            numbers = list(set(numbers))
            numbers = [num for num in numbers if num in number_range]
            numbers.sort()
            
            print(f"üîç ÊúÄÁªàÂè∑Á†ÅÊèêÂèñÁªìÊûú: {numbers}")
            return numbers
                
        except Exception as e:
            logger.warning(f"Âè∑Á†ÅÊèêÂèñÂ§±Ë¥•: {content_str}, ÈîôËØØ: {str(e)}")
            return []
    
    @lru_cache(maxsize=5000)
    def cached_extract_amount(self, amount_text):
        """Â∏¶ÁºìÂ≠òÁöÑÈáëÈ¢ùÊèêÂèñ"""
        return self.extract_bet_amount(amount_text)
    
    def extract_bet_amount(self, amount_text):
        """ÈáëÈ¢ùÊèêÂèñÂáΩÊï∞ - ‰øÆÂ§çÁâàÊú¨ÔºöÂè™ÊèêÂèñÁ¨¨‰∏Ä‰∏™Êï∞Â≠ó"""
        try:
            if pd.isna(amount_text) or amount_text is None:
                return 0.0
            
            # ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤Âπ∂Ê∏ÖÁêÜ
            text = str(amount_text).strip()
            
            # Â¶ÇÊûúÂ∑≤ÁªèÊòØÁ©∫Â≠óÁ¨¶‰∏≤ÔºåËøîÂõû0
            if text == '':
                return 0.0
            
            # ÊñπÊ≥ï1: Áõ¥Êé•ËΩ¨Êç¢ÔºàÂ§ÑÁêÜÁ∫ØÊï∞Â≠óÔºâ
            try:
                # ÁßªÈô§ÊâÄÊúâÈùûÊï∞Â≠óÂ≠óÁ¨¶ÔºàÈô§‰∫ÜÁÇπÂíåË¥üÂè∑Ôºâ
                clean_text = re.sub(r'[^\d.-]', '', text)
                if clean_text and clean_text != '-' and clean_text != '.':
                    amount = float(clean_text)
                    if amount >= 0:
                        return amount
            except:
                pass
            
            # ÊñπÊ≥ï2: Â§ÑÁêÜÂçÉ‰ΩçÂàÜÈöîÁ¨¶Ê†ºÂºè
            try:
                # ÁßªÈô§ÈÄóÂè∑ÂíåÂÖ®ËßíÈÄóÂè∑ÔºåÁÑ∂ÂêéËΩ¨Êç¢
                clean_text = text.replace(',', '').replace('Ôºå', '')
                amount = float(clean_text)
                if amount >= 0:
                    return amount
            except:
                pass
            
            # ÊñπÊ≥ï3: Â§ÑÁêÜ"5.000"ËøôÁßçÊ†ºÂºè
            if re.match(r'^\d+\.\d{3}$', text):
                try:
                    amount = float(text)
                    return amount
                except:
                    pass
            
            # ÊñπÊ≥ï4: ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊèêÂèñÁ¨¨‰∏Ä‰∏™Êï∞Â≠ó
            numbers = re.findall(r'\d+\.?\d*', text)
            if numbers:
                # Âè™ÂèñÁ¨¨‰∏Ä‰∏™ÂåπÈÖçÁöÑÊï∞Â≠óÔºåÈÅøÂÖç‰ªéÂÖ∂‰ªñÊñáÊú¨‰∏≠ÈîôËØØÊèêÂèñÂ§ö‰∏™Êï∞Â≠ó
                return float(numbers[0])
            
            return 0.0
            
        except Exception as e:
            logger.warning(f"ÈáëÈ¢ùÊèêÂèñÂ§±Ë¥•: {amount_text}, ÈîôËØØ: {str(e)}")
            return 0.0
    
    def calculate_similarity(self, avgs):
        """ËÆ°ÁÆóÈáëÈ¢ùÂåπÈÖçÂ∫¶"""
        if not avgs or max(avgs) == 0:
            return 0
        return (min(avgs) / max(avgs)) * 100
    
    def get_similarity_indicator(self, similarity):
        """Ëé∑ÂèñÁõ∏‰ººÂ∫¶È¢úËâ≤ÊåáÁ§∫Á¨¶"""
        thresholds = COVERAGE_CONFIG['similarity_thresholds']
        if similarity >= thresholds['excellent']: 
            return "üü¢"
        elif similarity >= thresholds['good']: 
            return "üü°"
        elif similarity >= thresholds['fair']: 
            return "üü†"
        else: 
            return "üî¥"
    
    def find_perfect_combinations(self, account_numbers, account_amount_stats, account_bet_contents, min_avg_amount, total_numbers):
        """ÂØªÊâæÂÆåÁæéÁªÑÂêà - ‰øÆÂ§çÁâàÊú¨ÔºöÁ°Æ‰øùÂπ∂ÈõÜÂÆåÁæéË¶ÜÁõñÊâÄÊúâÂè∑Á†ÅÔºå‰ΩÜÁßªÈô§Âçï‰∏™Ë¥¶Êà∑Âè∑Á†ÅÊï∞Èáè‰πãÂíåÁöÑÈôêÂà∂"""
        all_results = {2: [], 3: [], 4: []}
        all_accounts = list(account_numbers.keys())
        
        account_sets = {account: set(numbers) for account, numbers in account_numbers.items()}
        
        # ÊêúÁ¥¢2Ë¥¶Êà∑ÁªÑÂêà
        for i, acc1 in enumerate(all_accounts):
            count1 = len(account_numbers[acc1])
            for j in range(i+1, len(all_accounts)):
                acc2 = all_accounts[j]
                count2 = len(account_numbers[acc2])
                
                # üÜï ‰øÆÂ§çÔºöÁßªÈô§ count1 + count2 != total_numbers ÁöÑ‰∏•Ê†ºÈôêÂà∂
                # ‰ΩÜ‰ªçÁÑ∂Ê£ÄÊü•Âπ∂ÈõÜÊòØÂê¶ÂÆåÁæéË¶ÜÁõñ
                combined_set = account_sets[acc1] | account_sets[acc2]
                if len(combined_set) != total_numbers:  # Á°Æ‰øùÂÆåÁæéË¶ÜÁõñ
                    continue
                
                total_amount = account_amount_stats[acc1]['total_amount'] + account_amount_stats[acc2]['total_amount']
                avg_amounts = [
                    account_amount_stats[acc1]['avg_amount_per_number'],
                    account_amount_stats[acc2]['avg_amount_per_number']
                ]
                
                if min(avg_amounts) < float(min_avg_amount):
                    continue
                
                similarity = self.calculate_similarity(avg_amounts)
                
                result_data = {
                    'accounts': [acc1, acc2],
                    'account_count': 2,
                    'total_amount': total_amount,
                    'avg_amount_per_number': total_amount / total_numbers,
                    'similarity': similarity,
                    'similarity_indicator': self.get_similarity_indicator(similarity),
                    'individual_amounts': {
                        acc1: account_amount_stats[acc1]['total_amount'],
                        acc2: account_amount_stats[acc2]['total_amount']
                    },
                    'individual_avg_per_number': {
                        acc1: account_amount_stats[acc1]['avg_amount_per_number'],
                        acc2: account_amount_stats[acc2]['avg_amount_per_number']
                    },
                    'bet_contents': {
                        acc1: account_bet_contents[acc1],
                        acc2: account_bet_contents[acc2]
                    }
                }
                all_results[2].append(result_data)
        
        # ÊêúÁ¥¢3Ë¥¶Êà∑ÁªÑÂêà
        for i, acc1 in enumerate(all_accounts):
            count1 = len(account_numbers[acc1])
            for j in range(i+1, len(all_accounts)):
                acc2 = all_accounts[j]
                count2 = len(account_numbers[acc2])
                for k in range(j+1, len(all_accounts)):
                    acc3 = all_accounts[k]
                    count3 = len(account_numbers[acc3])
                    
                    # üÜï ‰øÆÂ§çÔºöÁßªÈô§ count1 + count2 + count3 != total_numbers ÁöÑ‰∏•Ê†ºÈôêÂà∂
                    # ‰ΩÜ‰ªçÁÑ∂Ê£ÄÊü•Âπ∂ÈõÜÊòØÂê¶ÂÆåÁæéË¶ÜÁõñ
                    combined_set = account_sets[acc1] | account_sets[acc2] | account_sets[acc3]
                    if len(combined_set) != total_numbers:  # Á°Æ‰øùÂÆåÁæéË¶ÜÁõñ
                        continue
                    
                    total_amount = (account_amount_stats[acc1]['total_amount'] + 
                                  account_amount_stats[acc2]['total_amount'] + 
                                  account_amount_stats[acc3]['total_amount'])
                    avg_amounts = [
                        account_amount_stats[acc1]['avg_amount_per_number'],
                        account_amount_stats[acc2]['avg_amount_per_number'],
                        account_amount_stats[acc3]['avg_amount_per_number']
                    ]
                    
                    if min(avg_amounts) < float(min_avg_amount):
                        continue
                    
                    similarity = self.calculate_similarity(avg_amounts)
                    
                    result_data = {
                        'accounts': [acc1, acc2, acc3],
                        'account_count': 3,
                        'total_amount': total_amount,
                        'avg_amount_per_number': total_amount / total_numbers,
                        'similarity': similarity,
                        'similarity_indicator': self.get_similarity_indicator(similarity),
                        'individual_amounts': {
                            acc1: account_amount_stats[acc1]['total_amount'],
                            acc2: account_amount_stats[acc2]['total_amount'],
                            acc3: account_amount_stats[acc3]['total_amount']
                        },
                        'individual_avg_per_number': {
                            acc1: account_amount_stats[acc1]['avg_amount_per_number'],
                            acc2: account_amount_stats[acc2]['avg_amount_per_number'],
                            acc3: account_amount_stats[acc3]['avg_amount_per_number']
                        },
                        'bet_contents': {
                            acc1: account_bet_contents[acc1],
                            acc2: account_bet_contents[acc2],
                            acc3: account_bet_contents[acc3]
                        }
                    }
                    all_results[3].append(result_data)
        
        # üÜï Êñ∞Â¢ûÔºöÊêúÁ¥¢4Ë¥¶Êà∑ÁªÑÂêà
        for i, acc1 in enumerate(all_accounts):
            count1 = len(account_numbers[acc1])
            for j in range(i+1, len(all_accounts)):
                acc2 = all_accounts[j]
                count2 = len(account_numbers[acc2])
                for k in range(j+1, len(all_accounts)):
                    acc3 = all_accounts[k]
                    count3 = len(account_numbers[acc3])
                    for l in range(k+1, len(all_accounts)):
                        acc4 = all_accounts[l]
                        count4 = len(account_numbers[acc4])
                        
                        # üÜï ‰øÆÂ§çÔºöÁßªÈô§ count1 + count2 + count3 + count4 != total_numbers ÁöÑ‰∏•Ê†ºÈôêÂà∂
                        # ‰ΩÜ‰ªçÁÑ∂Ê£ÄÊü•Âπ∂ÈõÜÊòØÂê¶ÂÆåÁæéË¶ÜÁõñ
                        combined_set = account_sets[acc1] | account_sets[acc2] | account_sets[acc3] | account_sets[acc4]
                        if len(combined_set) != total_numbers:  # Á°Æ‰øùÂÆåÁæéË¶ÜÁõñ
                            continue
                        
                        total_amount = (account_amount_stats[acc1]['total_amount'] + 
                                      account_amount_stats[acc2]['total_amount'] + 
                                      account_amount_stats[acc3]['total_amount'] +
                                      account_amount_stats[acc4]['total_amount'])
                        avg_amounts = [
                            account_amount_stats[acc1]['avg_amount_per_number'],
                            account_amount_stats[acc2]['avg_amount_per_number'],
                            account_amount_stats[acc3]['avg_amount_per_number'],
                            account_amount_stats[acc4]['avg_amount_per_number']
                        ]
                        
                        # Ê£ÄÊü•Âπ≥ÂùáÈáëÈ¢ùÊòØÂê¶ËææÂà∞ÈòàÂÄº
                        if min(avg_amounts) < float(min_avg_amount):
                            continue
                        
                        similarity = self.calculate_similarity(avg_amounts)
                        
                        result_data = {
                            'accounts': [acc1, acc2, acc3, acc4],
                            'account_count': 4,
                            'total_amount': total_amount,
                            'avg_amount_per_number': total_amount / total_numbers,
                            'similarity': similarity,
                            'similarity_indicator': self.get_similarity_indicator(similarity),
                            'individual_amounts': {
                                acc1: account_amount_stats[acc1]['total_amount'],
                                acc2: account_amount_stats[acc2]['total_amount'],
                                acc3: account_amount_stats[acc3]['total_amount'],
                                acc4: account_amount_stats[acc4]['total_amount']
                            },
                            'individual_avg_per_number': {
                                acc1: account_amount_stats[acc1]['avg_amount_per_number'],
                                acc2: account_amount_stats[acc2]['avg_amount_per_number'],
                                acc3: account_amount_stats[acc3]['avg_amount_per_number'],
                                acc4: account_amount_stats[acc4]['avg_amount_per_number']
                            },
                            'bet_contents': {
                                acc1: account_bet_contents[acc1],
                                acc2: account_bet_contents[acc2],
                                acc3: account_bet_contents[acc3],
                                acc4: account_bet_contents[acc4]
                            }
                        }
                        all_results[4].append(result_data)
        
        return all_results

    def analyze_period_lottery_position(self, group, period, lottery, position, min_number_count, min_avg_amount):
        """ÂàÜÊûêÁâπÂÆöÊúüÊï∞„ÄÅÂΩ©ÁßçÂíå‰ΩçÁΩÆ - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂè∑Á†ÅËåÉÂõ¥"""
        min_number_count = int(min_number_count)
        min_avg_amount = float(min_avg_amount)
        
        lottery_category = self.identify_lottery_category(lottery)
        if not lottery_category:
            print(f"‚ùå Êó†Ê≥ïËØÜÂà´ÂΩ©ÁßçÁ±ªÂûã: {lottery}")
            return None
        
        # üÜï ‰øÆÊ≠£ÔºöÊ†πÊçÆÁé©Ê≥ïËé∑ÂèñÊ≠£Á°ÆÁöÑÈÖçÁΩÆ
        config = self.get_play_specific_config(lottery_category, position)
        total_numbers = config['total_numbers']
        
        print(f"üîç ÂºÄÂßãÂàÜÊûê: {period} {lottery} {position}")
        print(f"üîç ÈÖçÁΩÆ: Âè∑Á†ÅËåÉÂõ¥={config['number_range']}, ÊÄªÂè∑Á†ÅÊï∞={total_numbers}")
        
        has_amount_column = 'ÊäïÊ≥®ÈáëÈ¢ù' in group.columns
        account_numbers = {}
        account_amount_stats = {}
        account_bet_contents = {}
        
        for account in group['‰ºöÂëòË¥¶Âè∑'].unique():
            account_data = group[group['‰ºöÂëòË¥¶Âè∑'] == account]
            
            all_numbers = set()
            total_amount = 0
            
            for _, row in account_data.iterrows():
                # üÜï Ë∞ÉËØïÔºöÊòæÁ§∫ÂéüÂßãÂÜÖÂÆπÂíåÊèêÂèñÁöÑÂè∑Á†Å
                print(f"üîç Â§ÑÁêÜË¥¶Êà∑ {account}: ÂÜÖÂÆπ='{row['ÂÜÖÂÆπ']}'")
                
                if 'ÊèêÂèñÂè∑Á†Å' in row:
                    numbers = row['ÊèêÂèñÂè∑Á†Å']
                else:
                    numbers = self.cached_extract_numbers(row['ÂÜÖÂÆπ'], lottery_category, position)
                
                print(f"‚úÖ ÊèêÂèñÂè∑Á†Å: {numbers}")
                all_numbers.update(numbers)
                
                if has_amount_column:
                    amount = row['ÊäïÊ≥®ÈáëÈ¢ù']
                    total_amount += amount
            
            account_numbers[account] = sorted(all_numbers)
            account_bet_contents[account] = ", ".join([f"{num:02d}" for num in sorted(all_numbers)])
            number_count = len(all_numbers)
            avg_amount_per_number = total_amount / number_count if number_count > 0 else 0
            
            account_amount_stats[account] = {
                'number_count': number_count,
                'total_amount': total_amount,
                'avg_amount_per_number': avg_amount_per_number
            }
            
            print(f"üìä Ë¥¶Êà∑ÁªüËÆ°: {account} -> Âè∑Á†ÅÊï∞={number_count}, ÊÄªÈáëÈ¢ù={total_amount}, Âπ≥Âùá={avg_amount_per_number}")
        
        # Á≠õÈÄâÊúâÊïàË¥¶Êà∑
        filtered_account_numbers = {}
        filtered_account_amount_stats = {}
        filtered_account_bet_contents = {}
        
        for account, numbers in account_numbers.items():
            stats = account_amount_stats[account]
            if len(numbers) >= min_number_count and stats['avg_amount_per_number'] >= min_avg_amount:
                filtered_account_numbers[account] = numbers
                filtered_account_amount_stats[account] = account_amount_stats[account]
                filtered_account_bet_contents[account] = account_bet_contents[account]
                print(f"‚úÖ ÊúâÊïàË¥¶Êà∑: {account} Âè∑Á†ÅÊï∞={len(numbers)} Âπ≥ÂùáÈáëÈ¢ù={stats['avg_amount_per_number']}")
            else:
                print(f"‚ùå Êó†ÊïàË¥¶Êà∑: {account} Âè∑Á†ÅÊï∞={len(numbers)} Âπ≥ÂùáÈáëÈ¢ù={stats['avg_amount_per_number']}")
        
        if len(filtered_account_numbers) < 2:
            print(f"‚ùå ÊúâÊïàË¥¶Êà∑‰∏çË∂≥: {len(filtered_account_numbers)} < 2")
            return None
        
        print(f"‚úÖ ÂºÄÂßãÂØªÊâæÂÆåÁæéÁªÑÂêàÔºåÊÄªÂè∑Á†ÅÊï∞={total_numbers}")
        all_results = self.find_perfect_combinations(
            filtered_account_numbers, 
            filtered_account_amount_stats, 
            filtered_account_bet_contents,
            min_avg_amount,
            total_numbers
        )
        
        total_combinations = sum(len(results) for results in all_results.values())
        print(f"üéØ ÊâæÂà∞ÁªÑÂêà: 2Ë¥¶Êà∑={len(all_results[2])}, 3Ë¥¶Êà∑={len(all_results[3])}, 4Ë¥¶Êà∑={len(all_results[4])}")
        
        if total_combinations > 0:
            all_combinations = []
            for results in all_results.values():
                all_combinations.extend(results)
            
            all_combinations.sort(key=lambda x: (x['account_count'], -x['similarity']))
            
            return {
                'period': period,
                'lottery': lottery,
                'position': position,
                'lottery_category': lottery_category,
                'total_combinations': total_combinations,
                'all_combinations': all_combinations,
                'filtered_accounts': len(filtered_account_numbers),
                'total_numbers': total_numbers
            }
        
        return None

    def analyze_account_behavior(self, df):
        """Êñ∞Â¢ûÔºöË¥¶Êà∑Ë°å‰∏∫ÂàÜÊûê"""
        account_stats = {}
        
        for account in df['‰ºöÂëòË¥¶Âè∑'].unique():
            account_data = df[df['‰ºöÂëòË¥¶Âè∑'] == account]
            
            # Âü∫Á°ÄÁªüËÆ°
            total_periods = account_data['ÊúüÂè∑'].nunique()
            total_records = len(account_data)
            total_lotteries = account_data['ÂΩ©Áßç'].nunique()
            
            # ÂΩ©ÁßçÂÅèÂ•ΩÂàÜÊûê
            lottery_preference = account_data['ÂΩ©Áßç'].value_counts().head(3).to_dict()
            
            # Áé©Ê≥ïÂÅèÂ•ΩÂàÜÊûê  
            play_preference = account_data['Áé©Ê≥ï'].value_counts().head(5).to_dict()
            
            # Ê¥ªË∑ÉÂ∫¶Á≠âÁ∫ß
            activity_level = self._get_activity_level(total_periods)
            
            account_stats[account] = {
                'total_periods': total_periods,
                'total_records': total_records,
                'total_lotteries': total_lotteries,
                'lottery_preference': lottery_preference,
                'play_preference': play_preference,
                'activity_level': activity_level,
                'avg_records_per_period': total_records / total_periods if total_periods > 0 else 0
            }
        
        return account_stats
    
    def _get_activity_level(self, total_periods):
        """Ëé∑ÂèñÊ¥ªË∑ÉÂ∫¶Á≠âÁ∫ß"""
        if total_periods <= 10:
            return '‰ΩéÊ¥ªË∑É'
        elif total_periods <= 50:
            return '‰∏≠Ê¥ªË∑É' 
        elif total_periods <= 100:
            return 'È´òÊ¥ªË∑É'
        else:
            return 'ÊûÅÈ´òÊ¥ªË∑É'
    
    def display_account_behavior_analysis(self, account_stats):
        """ÊòæÁ§∫Ë¥¶Êà∑Ë°å‰∏∫ÂàÜÊûêÁªìÊûú"""
        st.subheader("üë§ Ë¥¶Êà∑Ë°å‰∏∫ÂàÜÊûê")
        
        if not account_stats:
            st.info("ÊöÇÊó†Ë¥¶Êà∑Ë°å‰∏∫ÂàÜÊûêÊï∞ÊçÆ")
            return
        
        # ËΩ¨Êç¢‰∏∫DataFrame‰æø‰∫éÊòæÁ§∫
        stats_list = []
        for account, stats in account_stats.items():
            stats_list.append({
                'Ë¥¶Êà∑': account,
                'Ê¥ªË∑ÉÂ∫¶': stats['activity_level'],
                'ÊäïÊ≥®ÊúüÊï∞': stats['total_periods'],
                'ÊÄªËÆ∞ÂΩïÊï∞': stats['total_records'],
                'Ê∂âÂèäÂΩ©Áßç': stats['total_lotteries'],
                '‰∏ªË¶ÅÂΩ©Áßç': ', '.join([f"{k}({v})" for k, v in list(stats['lottery_preference'].items())[:2]]),
                'ÊúüÂùáËÆ∞ÂΩï': f"{stats['avg_records_per_period']:.1f}"
            })
        
        df_stats = pd.DataFrame(stats_list)
        df_stats = df_stats.sort_values('ÊäïÊ≥®ÊúüÊï∞', ascending=False)
        
        st.dataframe(
            df_stats,
            use_container_width=True,
            hide_index=True,
            height=min(400, len(df_stats) * 35 + 38)
        )
        
        # Ê¥ªË∑ÉÂ∫¶ÂàÜÂ∏É
        activity_dist = df_stats['Ê¥ªË∑ÉÂ∫¶'].value_counts()
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("ÊÄªË¥¶Êà∑Êï∞", len(account_stats))
        with col2:
            st.metric("È´òÊ¥ªË∑ÉË¥¶Êà∑", activity_dist.get('È´òÊ¥ªË∑É', 0) + activity_dist.get('ÊûÅÈ´òÊ¥ªË∑É', 0))
        with col3:
            st.metric("Âπ≥ÂùáÊúüÊï∞", f"{df_stats['ÊäïÊ≥®ÊúüÊï∞'].mean():.1f}")

    def analyze_with_progress(self, df_target, six_mark_params, ten_number_params, fast_three_params, analysis_mode):
        """Â∏¶ËøõÂ∫¶ÊòæÁ§∫ÁöÑÂàÜÊûê - ‰ΩøÁî®Â¢ûÂº∫ÈòàÂÄºÁÆ°ÁêÜ"""
        
        # Ê†πÊçÆÂàÜÊûêÊ®°ÂºèÂÜ≥ÂÆöÂàÜÁªÑÊñπÂºè
        if analysis_mode == "‰ªÖÂàÜÊûêÂÖ≠ÂêàÂΩ©":
            grouped = df_target.groupby(['ÊúüÂè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï'])
            min_number_count = six_mark_params['min_number_count']
            min_avg_amount = six_mark_params['min_avg_amount']
            
            # ‰ΩøÁî®ÈòàÂÄºÁÆ°ÁêÜ
            threshold_config = self.get_lottery_thresholds('six_mark', min_avg_amount)
            effective_min_avg_amount = threshold_config['min_avg_amount']
            
        elif analysis_mode == "‰ªÖÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶":
            grouped = df_target.groupby(['ÊúüÂè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï'])
            min_number_count = ten_number_params['min_number_count']
            min_avg_amount = ten_number_params['min_avg_amount']
            
            # ‰ΩøÁî®ÈòàÂÄºÁÆ°ÁêÜ
            threshold_config = self.get_lottery_thresholds('10_number', min_avg_amount)
            effective_min_avg_amount = threshold_config['min_avg_amount']
            
        elif analysis_mode == "‰ªÖÂàÜÊûêÂø´‰∏â":
            grouped = df_target.groupby(['ÊúüÂè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï'])
            min_number_count = fast_three_params['min_number_count']
            min_avg_amount = fast_three_params['min_avg_amount']
            
            # ‰ΩøÁî®ÈòàÂÄºÁÆ°ÁêÜ
            threshold_config = self.get_lottery_thresholds('fast_three', min_avg_amount)
            effective_min_avg_amount = threshold_config['min_avg_amount']
            
        else:  # Ëá™Âä®ËØÜÂà´ÊâÄÊúâÂΩ©Áßç
            # ÂàÜÂà´Â§ÑÁêÜ‰∏çÂêåÂΩ©ÁßçÔºå‰ΩøÁî®ÂêÑËá™ÁöÑÂ¢ûÂº∫ÈòàÂÄº
            df_six_mark = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == 'six_mark']
            df_10_number = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == '10_number']
            df_fast_three = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == 'fast_three']
            
            all_period_results = {}
            
            # ÂàÜÊûêÂÖ≠ÂêàÂΩ© - ‰ΩøÁî®Â¢ûÂº∫ÈòàÂÄº
            if len(df_six_mark) > 0:
                st.info("üîç Ê≠£Âú®ÂàÜÊûêÂÖ≠ÂêàÂΩ©Êï∞ÊçÆ...")
                grouped_six = df_six_mark.groupby(['ÊúüÂè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï'])
                for (period, lottery, position), group in grouped_six:
                    if len(group) >= 2:
                        threshold_config = self.get_lottery_thresholds('six_mark', six_mark_params['min_avg_amount'])
                        result = self.analyze_period_lottery_position(
                            group, period, lottery, position, 
                            six_mark_params['min_number_count'], 
                            six_mark_params['min_avg_amount']
                        )
                        if result:
                            all_period_results[(period, lottery, position)] = result
            
            # ÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶ - ‰ΩøÁî®Â¢ûÂº∫ÈòàÂÄº
            if len(df_10_number) > 0:
                st.info("üîç Ê≠£Âú®ÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶Êï∞ÊçÆ...")
                grouped_10 = df_10_number.groupby(['ÊúüÂè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï'])
                for (period, lottery, position), group in grouped_10:
                    if len(group) >= 2:
                        threshold_config = self.get_lottery_thresholds('10_number', ten_number_params['min_avg_amount'])
                        result = self.analyze_period_lottery_position(
                            group, period, lottery, position,
                            ten_number_params['min_number_count'],
                            ten_number_params['min_avg_amount']
                        )
                        if result:
                            all_period_results[(period, lottery, position)] = result
            
            # ÂàÜÊûêÂø´‰∏â - ‰ΩøÁî®Â¢ûÂº∫ÈòàÂÄº
            if len(df_fast_three) > 0:
                st.info("üé≤ Ê≠£Âú®ÂàÜÊûêÂø´‰∏âÊï∞ÊçÆ...")
                grouped_fast_three = df_fast_three.groupby(['ÊúüÂè∑', 'ÂΩ©Áßç', 'Áé©Ê≥ï'])
                for (period, lottery, position), group in grouped_fast_three:
                    if len(group) >= 2:
                        threshold_config = self.get_lottery_thresholds('fast_three', fast_three_params['min_avg_amount'])
                        result = self.analyze_period_lottery_position(
                            group, period, lottery, position,
                            fast_three_params['min_number_count'],
                            fast_three_params['min_avg_amount']
                        )
                        if result:
                            all_period_results[(period, lottery, position)] = result
            
            return all_period_results
        
        # ÈùûËá™Âä®ËØÜÂà´Ê®°ÂºèÁöÑËøõÂ∫¶ÊòæÁ§∫
        all_period_results = {}
        total_groups = len(grouped)
        
        if total_groups == 0:
            return all_period_results
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        for idx, (group_key, group) in enumerate(grouped):
            progress = (idx + 1) / total_groups
            progress_bar.progress(progress)
            
            period, lottery, position = group_key
            status_text.text(f"ÂàÜÊûêËøõÂ∫¶: {idx+1}/{total_groups} - {period} ({lottery} - {position})")
            
            if len(group) >= 2:
                result = self.analyze_period_lottery_position(
                    group, period, lottery, position, min_number_count, effective_min_avg_amount
                )
                if result:
                    all_period_results[(period, lottery, position)] = result
        
        progress_bar.empty()
        status_text.text("ÂàÜÊûêÂÆåÊàê!")
        
        return all_period_results

    def display_enhanced_results(self, all_period_results, analysis_mode):
        """Â¢ûÂº∫ÁªìÊûúÂ±ïÁ§∫ - ÊîØÊåÅ4Ë¥¶Êà∑ÁªÑÂêà"""
        if not all_period_results:
            st.info("üéâ Êú™ÂèëÁé∞ÂÆåÁæéË¶ÜÁõñÁªÑÂêà")
            return
        
        # üÜï Ë∞ÉËØïÔºöÊòæÁ§∫ÊâÄÊúâÊ£ÄÊµãÂà∞ÁöÑÁªìÊûú
        st.write(f"üîç Ë∞ÉËØï: ÊÄªÂÖ±Ê£ÄÊµãÂà∞ {len(all_period_results)} ‰∏™ÂàÜÁªÑÁöÑÁªìÊûú")
        
        for key, result in all_period_results.items():
            period, lottery, position = key
            st.write(f"üîç Ë∞ÉËØï: {period} {lottery} {position} -> {result['total_combinations']} ‰∏™ÁªÑÂêà")
            for combo in result['all_combinations']:
                accounts = combo['accounts']
                st.write(f"  - ÁªÑÂêà: {accounts}, Ë¥¶Êà∑Êï∞: {combo['account_count']}, Áõ∏‰ººÂ∫¶: {combo['similarity']}%")
        
        # ÊåâË¥¶Êà∑ÁªÑÂêàÂíåÂΩ©ÁßçÂàÜÁªÑ
        account_pair_groups = defaultdict(lambda: defaultdict(list))
        
        for group_key, result in all_period_results.items():
            lottery = result['lottery']
            position = result.get('position', None)
            
            for combo in result['all_combinations']:
                # ÂàõÂª∫Ë¥¶Êà∑ÁªÑÂêàÈîÆ
                accounts = combo['accounts']
                account_pair = " ‚Üî ".join(sorted(accounts))
                
                # ÂàõÂª∫ÂΩ©ÁßçÈîÆ
                if position:
                    lottery_key = f"{lottery} - {position}"
                else:
                    lottery_key = lottery
                
                # Â≠òÂÇ®ÁªÑÂêà‰ø°ÊÅØ
                combo_info = {
                    'period': result['period'],
                    'combo': combo,
                    'lottery_category': result['lottery_category'],
                    'total_numbers': result['total_numbers']
                }
                
                account_pair_groups[account_pair][lottery_key].append(combo_info)
        
        # üÜï Ë∞ÉËØïÔºöÊòæÁ§∫ÂàÜÁªÑÂêéÁöÑÁªìÊûú
        st.write(f"üîç Ë∞ÉËØï: ÂàÜÁªÑÂêéÂÖ±Êúâ {len(account_pair_groups)} ‰∏™Ë¥¶Êà∑ÁªÑÂêà")
        for account_pair, lottery_groups in account_pair_groups.items():
            st.write(f"üîç Ë∞ÉËØï: Ë¥¶Êà∑ÁªÑÂêà {account_pair}")
            for lottery_key, combos in lottery_groups.items():
                st.write(f"  - {lottery_key}: {len(combos)} ‰∏™ÁªÑÂêà")
        
        # ÊòæÁ§∫ÂΩ©ÁßçÁ±ªÂûãÁªüËÆ° - Êõ¥Êñ∞‰∏∫ÊòæÁ§∫ÂêÑÁßçÁªÑÂêàÁ±ªÂûãÁöÑÊï∞Èáè
        st.subheader("üé≤ ÁªÑÂêàÁ±ªÂûãÁªüËÆ°")
        col1, col2, col3, col4 = st.columns(4)
        
        # ËÆ°ÁÆóÂêÑÁ±ªÂûãÁªÑÂêàÊï∞Èáè
        combo_type_stats = {2: 0, 3: 0, 4: 0}
        for result in all_period_results.values():
            for combo in result['all_combinations']:
                combo_type_stats[combo['account_count']] += 1
        
        with col1:
            st.metric("2Ë¥¶Êà∑ÁªÑÂêà", f"{combo_type_stats[2]}ÁªÑ")
        with col2:
            st.metric("3Ë¥¶Êà∑ÁªÑÂêà", f"{combo_type_stats[3]}ÁªÑ")
        with col3:
            st.metric("4Ë¥¶Êà∑ÁªÑÂêà", f"{combo_type_stats[4]}ÁªÑ")
        with col4:
            total_combinations = sum(combo_type_stats.values())
            st.metric("ÊÄªÁªÑÂêàÊï∞", f"{total_combinations}ÁªÑ")
        
        # ÊòæÁ§∫Ê±áÊÄªÁªüËÆ°
        st.subheader("üìä Ê£ÄÊµãÊ±áÊÄª")
        total_combinations = sum(result['total_combinations'] for result in all_period_results.values())
        total_filtered_accounts = sum(result['filtered_accounts'] for result in all_period_results.values())
        total_periods = len(set(result['period'] for result in all_period_results.values()))
        total_lotteries = len(set(result['lottery'] for result in all_period_results.values()))
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("ÊÄªÂÆåÁæéÁªÑÂêàÊï∞", total_combinations)
        with col2:
            st.metric("ÂàÜÊûêÊúüÊï∞", total_periods)
        with col3:
            st.metric("ÊúâÊïàË¥¶Êà∑Êï∞", total_filtered_accounts)
        with col4:
            st.metric("Ê∂âÂèäÂΩ©Áßç", total_lotteries)
        
        # ÂèÇ‰∏éË¥¶Êà∑ËØ¶ÁªÜÁªüËÆ°
        st.subheader("üë• ÂèÇ‰∏éË¥¶Êà∑ËØ¶ÁªÜÁªüËÆ°")
        account_stats = self._calculate_detailed_account_stats(all_period_results)
        
        if account_stats:
            df_stats = pd.DataFrame(account_stats)
            
            st.dataframe(
                df_stats,
                use_container_width=True,
                hide_index=True,
                height=min(400, len(df_stats) * 35 + 38)
            )
        
        # ÊòæÁ§∫ËØ¶ÁªÜÁªÑÂêàÂàÜÊûê
        st.subheader("üìà ËØ¶ÁªÜÁªÑÂêàÂàÜÊûê")
        self._display_by_account_pair_lottery(account_pair_groups, analysis_mode)

    def _calculate_detailed_account_stats(self, all_period_results):
        """ËØ¶ÁªÜË¥¶Êà∑ÁªüËÆ° - ÊîØÊåÅ4Ë¥¶Êà∑ÁªÑÂêàÂíåÂ∞æÊï∞Áé©Ê≥ï"""
        account_stats = []
        account_participation = defaultdict(lambda: {
            'periods': set(),
            'lotteries': set(),
            'positions': set(),
            'total_combinations': 0,
            'total_bet_amount': 0,
            'combo_types': set()  # Êñ∞Â¢ûÔºöËÆ∞ÂΩïÂèÇ‰∏éÁöÑÁªÑÂêàÁ±ªÂûã
        })
        
        for result in all_period_results.values():
            for combo in result['all_combinations']:
                for account in combo['accounts']:
                    account_info = account_participation[account]
                    account_info['periods'].add(result['period'])
                    account_info['lotteries'].add(result['lottery'])
                    if 'position' in result:
                        account_info['positions'].add(result['position'])
                    account_info['total_combinations'] += 1
                    account_info['total_bet_amount'] += combo['individual_amounts'][account]
                    account_info['combo_types'].add(combo['account_count'])  # ËÆ∞ÂΩïÁªÑÂêàÁ±ªÂûã
        
        for account, info in account_participation.items():
            stat_record = {
                'Ë¥¶Êà∑': account,
                'ÂèÇ‰∏éÁªÑÂêàÊï∞': info['total_combinations'],
                'Ê∂âÂèäÊúüÊï∞': len(info['periods']),
                'Ê∂âÂèäÂΩ©Áßç': len(info['lotteries']),
                'ÁªÑÂêàÁ±ªÂûã': ', '.join([f"{t}Ë¥¶Êà∑" for t in sorted(info['combo_types'])]),  # Êñ∞Â¢ûÁªÑÂêàÁ±ªÂûã‰ø°ÊÅØ
                'ÊÄªÊäïÊ≥®ÈáëÈ¢ù': info['total_bet_amount'],
                'Âπ≥ÂùáÊØèÊúüÈáëÈ¢ù': info['total_bet_amount'] / len(info['periods']) if info['periods'] else 0
            }
            
            if info['positions']:
                stat_record['Ê∂âÂèä‰ΩçÁΩÆ'] = ', '.join(sorted(info['positions']))
            
            account_stats.append(stat_record)
        
        return sorted(account_stats, key=lambda x: x['ÂèÇ‰∏éÁªÑÂêàÊï∞'], reverse=True)

    def _display_by_account_pair_lottery(self, account_pair_groups, analysis_mode):
        """ÊåâË¥¶Êà∑ÁªÑÂêàÂíåÂΩ©ÁßçÂ±ïÁ§∫ - ‰øÆÂ§çÁâàÊú¨"""
        category_display = {
            'six_mark': 'ÂÖ≠ÂêàÂΩ©',
            'six_mark_tail': 'ÂÖ≠ÂêàÂΩ©Â∞æÊï∞',  # üÜï Êñ∞Â¢ûÂ∞æÊï∞Á±ªÂà´ÊòæÁ§∫
            '10_number': 'Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶',
            'fast_three': 'Âø´‰∏â'
        }
        
        # üÜï Ë∞ÉËØïÔºöÊòæÁ§∫ÊâÄÊúâË¶ÅÂ±ïÁ§∫ÁöÑÁªÑÂêà
        if not account_pair_groups:
            st.info("‚ùå Ê≤°ÊúâÊâæÂà∞Ë¶ÅÂ±ïÁ§∫ÁöÑÁªÑÂêà")
            return
        
        # ÈÅçÂéÜÊØè‰∏™Ë¥¶Êà∑ÁªÑÂêà
        for account_pair, lottery_groups in account_pair_groups.items():
            # üÜï Ë∞ÉËØïÔºöÊòæÁ§∫ÂΩìÂâçÂ§ÑÁêÜÁöÑË¥¶Êà∑ÁªÑÂêà
            st.write(f"üîç Â§ÑÁêÜË¥¶Êà∑ÁªÑÂêà: {account_pair}")
            
            # ÈÅçÂéÜÊØè‰∏™ÂΩ©Áßç
            for lottery_key, combos in lottery_groups.items():
                # ÊåâÊúüÂè∑ÊéíÂ∫è
                combos.sort(key=lambda x: x['period'])
                
                # ÂàõÂª∫ÊäòÂè†Ê°ÜÊ†áÈ¢ò
                combo_count = len(combos)
                title = f"**{account_pair}** - {lottery_key}Ôºà{combo_count}‰∏™ÁªÑÂêàÔºâ"
                
                with st.expander(title, expanded=True):
                    # ÊòæÁ§∫ÊØè‰∏™ÁªÑÂêà
                    for idx, combo_info in enumerate(combos, 1):
                        combo = combo_info['combo']
                        period = combo_info['period']
                        lottery_category = combo_info['lottery_category']
                        
                        # ÁªÑÂêàÊ†áÈ¢ò
                        st.markdown(f"**ÂÆåÁæéÁªÑÂêà {idx}:** {account_pair}")
                        
                        # ÁªÑÂêà‰ø°ÊÅØ
                        col1, col2, col3, col4 = st.columns(4)
                        with col1:
                            st.write(f"**Ë¥¶Êà∑Êï∞Èáè:** {combo['account_count']}‰∏™")
                        with col2:
                            st.write(f"**ÊúüÂè∑:** {period}")
                        with col3:
                            st.write(f"**ÊÄªÈáëÈ¢ù:** ¬•{combo['total_amount']:,.2f}")
                        with col4:
                            similarity = combo['similarity']
                            indicator = combo['similarity_indicator']
                            st.write(f"**ÈáëÈ¢ùÂåπÈÖçÂ∫¶:** {similarity:.1f}% {indicator}")
                        
                        # ÂΩ©ÁßçÁ±ªÂûã‰ø°ÊÅØ
                        category_name = category_display.get(lottery_category, lottery_category)
                        st.write(f"**ÂΩ©ÁßçÁ±ªÂûã:** {category_name}")
                        
                        # ÂêÑË¥¶Êà∑ËØ¶ÊÉÖ
                        st.write("**ÂêÑË¥¶Êà∑ËØ¶ÊÉÖ:**")
                        
                        for account in combo['accounts']:
                            amount_info = combo['individual_amounts'][account]
                            avg_info = combo['individual_avg_per_number'][account]
                            numbers = combo['bet_contents'][account]
                            numbers_count = len(numbers.split(', '))
                            
                            st.write(f"- **{account}**: {numbers_count}‰∏™Êï∞Â≠ó")
                            st.write(f"  - ÊÄªÊäïÊ≥®: ¬•{amount_info:,.2f}")
                            st.write(f"  - Âπ≥ÂùáÊØèÂè∑: ¬•{avg_info:,.2f}")
                            st.write(f"  - ÊäïÊ≥®ÂÜÖÂÆπ: {numbers}")
                        
                        # Ê∑ªÂä†ÂàÜÈöîÁ∫øÔºàÈô§‰∫ÜÊúÄÂêé‰∏Ä‰∏™ÁªÑÂêàÔºâ
                        if idx < len(combos):
                            st.markdown("---")

    def enhanced_export(self, all_period_results, analysis_mode):
        """Â¢ûÂº∫ÂØºÂá∫ÂäüËÉΩ - ÊîØÊåÅ4Ë¥¶Êà∑ÁªÑÂêà"""
        export_data = []
        
        category_display = {
            'six_mark': 'ÂÖ≠ÂêàÂΩ©',
            '10_number': 'Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶',
            'fast_three': 'Âø´‰∏â'
        }
        
        for group_key, result in all_period_results.values():
            lottery_category = result['lottery_category']
            total_numbers = result['total_numbers']
            
            for combo in result['all_combinations']:
                # Âü∫Á°Ä‰ø°ÊÅØ
                export_record = {
                    'ÊúüÂè∑': result['period'],
                    'ÂΩ©Áßç': result['lottery'],
                    'ÂΩ©ÁßçÁ±ªÂûã': category_display.get(lottery_category, lottery_category),
                    'Âè∑Á†ÅÊÄªÊï∞': total_numbers,
                    'ÁªÑÂêàÁ±ªÂûã': f"{combo['account_count']}Ë¥¶Êà∑ÁªÑÂêà",  # Áé∞Âú®ÊîØÊåÅ2,3,4Ë¥¶Êà∑
                    'Ë¥¶Êà∑ÁªÑÂêà': ' ‚Üî '.join(combo['accounts']),
                    'ÊÄªÊäïÊ≥®ÈáëÈ¢ù': combo['total_amount'],
                    'Âπ≥ÂùáÊØèÂè∑ÈáëÈ¢ù': combo['avg_amount_per_number'],
                    'ÈáëÈ¢ùÂåπÈÖçÂ∫¶': f"{combo['similarity']:.1f}%",
                    'ÂåπÈÖçÂ∫¶Á≠âÁ∫ß': combo['similarity_indicator']
                }
                
                # Ê∑ªÂä†‰ΩçÁΩÆ‰ø°ÊÅØ
                if 'position' in result and result['position']:
                    export_record['ÊäïÊ≥®‰ΩçÁΩÆ'] = result['position']
                
                # ÂêÑË¥¶Êà∑ËØ¶ÊÉÖ - Áé∞Âú®ÊúÄÂ§öÊîØÊåÅ4‰∏™Ë¥¶Êà∑
                for i, account in enumerate(combo['accounts'], 1):
                    export_record[f'Ë¥¶Êà∑{i}'] = account
                    export_record[f'Ë¥¶Êà∑{i}ÊÄªÈáëÈ¢ù'] = combo['individual_amounts'][account]
                    export_record[f'Ë¥¶Êà∑{i}Âπ≥ÂùáÊØèÂè∑'] = combo['individual_avg_per_number'][account]
                    export_record[f'Ë¥¶Êà∑{i}Âè∑Á†ÅÊï∞Èáè'] = len(combo['bet_contents'][account].split(', '))
                    export_record[f'Ë¥¶Êà∑{i}ÊäïÊ≥®ÂÜÖÂÆπ'] = combo['bet_contents'][account]
                
                export_data.append(export_record)
        
        return pd.DataFrame(export_data)

# ==================== StreamlitÁïåÈù¢ ====================
def main():
    st.title("üéØ ÂΩ©Á•®ÂÆåÁæéË¶ÜÁõñÂàÜÊûêÁ≥ªÁªü")
    st.markdown("### ÊîØÊåÅÂÖ≠ÂêàÂΩ©„ÄÅÊó∂Êó∂ÂΩ©„ÄÅPK10„ÄÅËµõËΩ¶„ÄÅÂø´‰∏âÁ≠âÂ§öÁßçÂΩ©Á•®ÁöÑÊô∫ËÉΩÂØπÂà∑Ê£ÄÊµã")
    
    analyzer = MultiLotteryCoverageAnalyzer()
    
    # ‰æßËæπÊ†èËÆæÁΩÆ - ÂàÜÂà´ËÆæÁΩÆ‰∏çÂêåÂΩ©ÁßçÁöÑÈòàÂÄº
    st.sidebar.header("‚öôÔ∏è ÂàÜÊûêÂèÇÊï∞ËÆæÁΩÆ")
    
    # Êñá‰ª∂‰∏ä‰º†
    st.sidebar.header("üìÅ Êï∞ÊçÆ‰∏ä‰º†")
    uploaded_file = st.sidebar.file_uploader(
        "‰∏ä‰º†ÊäïÊ≥®Êï∞ÊçÆÊñá‰ª∂", 
        type=['csv', 'xlsx', 'xls'],
        help="ËØ∑‰∏ä‰º†ÂåÖÂê´ÂΩ©Á•®ÊäïÊ≥®Êï∞ÊçÆÁöÑExcelÊàñCSVÊñá‰ª∂"
    )
    
    # Ê∑ªÂä†ÂΩ©ÁßçÁ±ªÂûãÈÄâÊã©
    analysis_mode = st.sidebar.radio(
        "ÂàÜÊûêÊ®°Âºè:",
        ["Ëá™Âä®ËØÜÂà´ÊâÄÊúâÂΩ©Áßç", "‰ªÖÂàÜÊûêÂÖ≠ÂêàÂΩ©", "‰ªÖÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶", "‰ªÖÂàÜÊûêÂø´‰∏â"],
        help="ÈÄâÊã©Ë¶ÅÂàÜÊûêÁöÑÂΩ©ÁßçÁ±ªÂûã"
    )
    
    st.sidebar.subheader("üéØ ÂÖ≠ÂêàÂΩ©ÂèÇÊï∞ËÆæÁΩÆ")
    
    # ÂÖ≠ÂêàÂΩ©‰∏ìÁî®ÈòàÂÄºËÆæÁΩÆ
    six_mark_min_number_count = st.sidebar.slider(
        "ÂÖ≠ÂêàÂΩ©-Âè∑Á†ÅÊï∞ÈáèÈòàÂÄº", 
        min_value=1, 
        max_value=30, 
        value=11,
        help="ÂÖ≠ÂêàÂΩ©ÔºöÂè™ÂàÜÊûêÊäïÊ≥®Âè∑Á†ÅÊï∞ÈáèÂ§ß‰∫éÁ≠â‰∫éÊ≠§ÂÄºÁöÑË¥¶Êà∑"
    )
    
    six_mark_min_avg_amount = st.sidebar.slider(
        "ÂÖ≠ÂêàÂΩ©-Âπ≥ÂùáÈáëÈ¢ùÈòàÂÄº", 
        min_value=0, 
        max_value=50,  # Ë∞ÉÈ´òÊúÄÂ§ßÂÄº
        value=10,      # ‰øÆÊîπÔºö‰ªé2Êîπ‰∏∫10
        step=1,
        help="ÂÖ≠ÂêàÂΩ©ÔºöÂè™ÂàÜÊûêÂπ≥ÂùáÊØèÂè∑ÈáëÈ¢ùÂ§ß‰∫éÁ≠â‰∫é10ÁöÑË¥¶Êà∑"  # Êõ¥Êñ∞Â∏ÆÂä©ÊñáÊú¨
    )
    
    # Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶‰∏ìÁî®ÈòàÂÄºËÆæÁΩÆ
    ten_number_min_number_count = st.sidebar.slider(
        "ËµõËΩ¶Á±ª-Âè∑Á†ÅÊï∞ÈáèÈòàÂÄº", 
        min_value=1, 
        max_value=10, 
        value=3,
        help="Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶ÔºöÂè™ÂàÜÊûêÊäïÊ≥®Âè∑Á†ÅÊï∞ÈáèÂ§ß‰∫éÁ≠â‰∫éÊ≠§ÂÄºÁöÑË¥¶Êà∑"
    )
    
    ten_number_min_avg_amount = st.sidebar.slider(
        "ËµõËΩ¶Á±ª-Âπ≥ÂùáÈáëÈ¢ùÈòàÂÄº", 
        min_value=0, 
        max_value=20,  # Ë∞ÉÈ´òÊúÄÂ§ßÂÄº
        value=5,       # ‰øÆÊîπÔºö‰ªé1Êîπ‰∏∫5
        step=1,
        help="Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶ÔºöÂè™ÂàÜÊûêÂπ≥ÂùáÊØèÂè∑ÈáëÈ¢ùÂ§ß‰∫éÁ≠â‰∫é5ÁöÑË¥¶Êà∑"  # Êõ¥Êñ∞Â∏ÆÂä©ÊñáÊú¨
    )
    
    # Âø´‰∏â‰∏ìÁî®ÈòàÂÄºËÆæÁΩÆ
    fast_three_min_number_count = st.sidebar.slider(
        "Âø´‰∏â-Âè∑Á†ÅÊï∞ÈáèÈòàÂÄº", 
        min_value=1, 
        max_value=16, 
        value=4,
        help="Âø´‰∏âÂíåÂÄºÁé©Ê≥ïÔºöÂè™ÂàÜÊûêÊäïÊ≥®Âè∑Á†ÅÊï∞ÈáèÂ§ß‰∫éÁ≠â‰∫éÊ≠§ÂÄºÁöÑË¥¶Êà∑"
    )
    
    fast_three_min_avg_amount = st.sidebar.slider(
        "Âø´‰∏â-Âπ≥ÂùáÈáëÈ¢ùÈòàÂÄº", 
        min_value=0, 
        max_value=20,  # Ë∞ÉÈ´òÊúÄÂ§ßÂÄº
        value=5,       # ‰øÆÊîπÔºö‰ªé1Êîπ‰∏∫5
        step=1,
        help="Âø´‰∏âÂíåÂÄºÁé©Ê≥ïÔºöÂè™ÂàÜÊûêÂπ≥ÂùáÊØèÂè∑ÈáëÈ¢ùÂ§ß‰∫éÁ≠â‰∫é5ÁöÑË¥¶Êà∑"  # Êõ¥Êñ∞Â∏ÆÂä©ÊñáÊú¨
    )
    
    if uploaded_file is not None:
        try:
            # ËØªÂèñÊñá‰ª∂ - Â¢ûÂº∫ÁºñÁ†ÅÂ§ÑÁêÜ
            if uploaded_file.name.endswith('.csv'):
                try:
                    # ÂÖàÂ∞ùËØïUTF-8
                    df = pd.read_csv(uploaded_file)
                except UnicodeDecodeError:
                    # Â¶ÇÊûúUTF-8Â§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÁºñÁ†Å
                    uploaded_file.seek(0)  # ÈáçÁΩÆÊñá‰ª∂ÊåáÈíà
                    try:
                        df = pd.read_csv(uploaded_file, encoding='gbk')
                    except:
                        uploaded_file.seek(0)
                        try:
                            df = pd.read_csv(uploaded_file, encoding='gb2312')
                        except:
                            uploaded_file.seek(0)
                            # ÊúÄÂêéÂ∞ùËØïÂøΩÁï•ÈîôËØØ
                            df = pd.read_csv(uploaded_file, encoding_errors='ignore')
            else:
                df = pd.read_excel(uploaded_file)
            
            st.success(f"‚úÖ ÊàêÂäüËØªÂèñÊñá‰ª∂ÔºåÂÖ± {len(df):,} Êù°ËÆ∞ÂΩï")
            
            # Ê†πÊçÆÈÄâÊã©ÁöÑÂàÜÊûêÊ®°ÂºèÊòæÁ§∫ÂΩìÂâçÈòàÂÄºËÆæÁΩÆ
            if analysis_mode == "‰ªÖÂàÜÊûêÂÖ≠ÂêàÂΩ©":
                st.info(f"üìä ÂΩìÂâçÂàÜÊûêÊ®°Âºè: {analysis_mode}")
                threshold_config = analyzer.get_lottery_thresholds('six_mark', six_mark_min_avg_amount)
                st.info(f"üéØ ÂÖ≠ÂêàÂΩ©ÂèÇÊï∞: Âè∑Á†ÅÊï∞ÈáèÈòàÂÄº ‚â• {six_mark_min_number_count}, Âπ≥ÂùáÈáëÈ¢ùÈòàÂÄº ‚â• {threshold_config['min_avg_amount']}")
            elif analysis_mode == "‰ªÖÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶":
                st.info(f"üìä ÂΩìÂâçÂàÜÊûêÊ®°Âºè: {analysis_mode}")
                threshold_config = analyzer.get_lottery_thresholds('10_number', ten_number_min_avg_amount)
                st.info(f"üèéÔ∏è ËµõËΩ¶Á±ªÂèÇÊï∞: Âè∑Á†ÅÊï∞ÈáèÈòàÂÄº ‚â• {ten_number_min_number_count}, Âπ≥ÂùáÈáëÈ¢ùÈòàÂÄº ‚â• {threshold_config['min_avg_amount']}")
            elif analysis_mode == "‰ªÖÂàÜÊûêÂø´‰∏â":
                st.info(f"üìä ÂΩìÂâçÂàÜÊûêÊ®°Âºè: {analysis_mode}")
                threshold_config = analyzer.get_lottery_thresholds('fast_three', fast_three_min_avg_amount)
                st.info(f"üé≤ Âø´‰∏âÂèÇÊï∞: Âè∑Á†ÅÊï∞ÈáèÈòàÂÄº ‚â• {fast_three_min_number_count}, Âπ≥ÂùáÈáëÈ¢ùÈòàÂÄº ‚â• {threshold_config['min_avg_amount']}")
            else:
                st.info(f"üìä ÂΩìÂâçÂàÜÊûêÊ®°Âºè: {analysis_mode}")
                six_mark_config = analyzer.get_lottery_thresholds('six_mark', six_mark_min_avg_amount)
                ten_number_config = analyzer.get_lottery_thresholds('10_number', ten_number_min_avg_amount)
                fast_three_config = analyzer.get_lottery_thresholds('fast_three', fast_three_min_avg_amount)
                st.info(f"üéØ ÂÖ≠ÂêàÂΩ©ÂèÇÊï∞: Âè∑Á†ÅÊï∞Èáè ‚â• {six_mark_min_number_count}, Âπ≥ÂùáÈáëÈ¢ù ‚â• {six_mark_config['min_avg_amount']}")
                st.info(f"üèéÔ∏è ËµõËΩ¶Á±ªÂèÇÊï∞: Âè∑Á†ÅÊï∞Èáè ‚â• {ten_number_min_number_count}, Âπ≥ÂùáÈáëÈ¢ù ‚â• {ten_number_config['min_avg_amount']}")
                st.info(f"üé≤ Âø´‰∏âÂèÇÊï∞: Âè∑Á†ÅÊï∞Èáè ‚â• {fast_three_min_number_count}, Âπ≥ÂùáÈáëÈ¢ù ‚â• {fast_three_config['min_avg_amount']}")
            
            # Â∞ÜÂàóÂêçËØÜÂà´ÂíåÊï∞ÊçÆË¥®ÈáèÊ£ÄÊü•ÊîæÂÖ•ÊäòÂè†Ê°Ü
            with st.expander("üîß Êï∞ÊçÆÈ¢ÑÂ§ÑÁêÜËøáÁ®ã", expanded=False):
                # Â¢ûÂº∫ÁâàÂàóÂêçÊò†Â∞Ñ
                with st.spinner("Ê≠£Âú®ËøõË°åÂàóÂêçËØÜÂà´..."):
                    column_mapping = analyzer.enhanced_column_mapping(df)
                
                if column_mapping is None:
                    st.error("‚ùå ÂàóÂêçÊò†Â∞ÑÂ§±Ë¥•ÔºåÊó†Ê≥ïÁªßÁª≠ÂàÜÊûê")
                    return
                
                df = df.rename(columns=column_mapping)
                st.success("‚úÖ ÂàóÂêçÊò†Â∞ÑÂÆåÊàê")
    
                # Êï∞ÊçÆË¥®ÈáèÈ™åËØÅ
                with st.spinner("Ê≠£Âú®ËøõË°åÊï∞ÊçÆË¥®ÈáèÈ™åËØÅ..."):
                    quality_issues = analyzer.validate_data_quality(df)
            
            # Êï∞ÊçÆÊ∏ÖÁêÜ
            required_columns = ['‰ºöÂëòË¥¶Âè∑', 'ÂΩ©Áßç', 'ÊúüÂè∑', 'Áé©Ê≥ï', 'ÂÜÖÂÆπ']
            available_columns = [col for col in required_columns if col in df.columns]
            
            has_amount_column = 'ÈáëÈ¢ù' in df.columns
            if has_amount_column:
                available_columns.append('ÈáëÈ¢ù')
                st.success("üí∞ Ê£ÄÊµãÂà∞ÈáëÈ¢ùÂàóÔºåÂ∞ÜËøõË°åÈáëÈ¢ùÂàÜÊûê")
            else:
                st.warning("‚ö†Ô∏è Êú™Ê£ÄÊµãÂà∞ÈáëÈ¢ùÂàóÔºåÂ∞ÜÂè™ÂàÜÊûêÂè∑Á†ÅË¶ÜÁõñ")

            if len(available_columns) >= 5:
                df_clean = df[available_columns].copy()
                df_clean = df_clean.dropna(subset=required_columns)
                
                for col in available_columns:
                    df_clean[col] = df_clean[col].astype(str).str.strip()

                with st.spinner("üìä Ê≠£Âú®ËøõË°åË¥¶Êà∑Ë°å‰∏∫ÂàÜÊûê..."):
                    account_behavior_stats = analyzer.analyze_account_behavior(df_clean)
                    analyzer.display_account_behavior_analysis(account_behavior_stats)
                
                # Áªü‰∏ÄÁöÑÊï∞ÊçÆÈ¢ÑÂ§ÑÁêÜ
                with st.spinner("Ê≠£Âú®ËøõË°åÊï∞ÊçÆÈ¢ÑÂ§ÑÁêÜ..."):
                    df_clean, no_number_count, non_number_play_count = analyzer.enhanced_data_preprocessing(df_clean)
                    st.success(f"‚úÖ Êï∞ÊçÆÈ¢ÑÂ§ÑÁêÜÂÆåÊàê: ‰øùÁïô {len(df_clean)} Êù°ÊúâÊïàËÆ∞ÂΩï")
                    if no_number_count > 0 or non_number_play_count > 0:
                        st.info(f"üìä ËøáÊª§ÁªüËÆ°: ÁßªÈô§‰∫Ü {no_number_count} Êù°Êó†Âè∑Á†ÅËÆ∞ÂΩïÂíå {non_number_play_count} Êù°ÈùûÂè∑Á†ÅÁé©Ê≥ïËÆ∞ÂΩï")
                
                # ‰ªéÊäïÊ≥®ÂÜÖÂÆπ‰∏≠ÊèêÂèñÂÖ∑‰Ωì‰ΩçÁΩÆ‰ø°ÊÅØ
                with st.spinner("Ê≠£Âú®‰ªéÊäïÊ≥®ÂÜÖÂÆπ‰∏≠ÊèêÂèñÂÖ∑‰Ωì‰ΩçÁΩÆ‰ø°ÊÅØ..."):
                    # ÂàõÂª∫‰∏¥Êó∂ÂàóÊù•Â≠òÂÇ®‰ªéÂÜÖÂÆπ‰∏≠ÊèêÂèñÁöÑ‰ΩçÁΩÆ
                    df_clean['ÊèêÂèñ‰ΩçÁΩÆ'] = df_clean.apply(
                        lambda row: analyzer.enhanced_extract_position_from_content(
                            row['Áé©Ê≥ï'], row['ÂÜÖÂÆπ'], row['ÂΩ©ÁßçÁ±ªÂûã'] if 'ÂΩ©ÁßçÁ±ªÂûã' in df_clean.columns else 'six_mark'
                        ), 
                        axis=1
                    )
                    
                    # ÂØπ‰∫éÊàêÂäüÊèêÂèñÂà∞ÂÖ∑‰Ωì‰ΩçÁΩÆÁöÑËÆ∞ÂΩïÔºåÊõ¥Êñ∞Áé©Ê≥ïÂàó‰∏∫ÊèêÂèñÁöÑ‰ΩçÁΩÆ
                    mask = df_clean['ÊèêÂèñ‰ΩçÁΩÆ'] != df_clean['Áé©Ê≥ï']
                    if mask.sum() > 0:
                        st.success(f"‚úÖ ‰ªéÂÜÖÂÆπ‰∏≠ÊèêÂèñÂà∞ {mask.sum()} Êù°ËÆ∞ÂΩïÁöÑÂÖ∑‰Ωì‰ΩçÁΩÆ‰ø°ÊÅØ")
                        df_clean.loc[mask, 'Áé©Ê≥ï'] = df_clean.loc[mask, 'ÊèêÂèñ‰ΩçÁΩÆ']
                    
                    # Âà†Èô§‰∏¥Êó∂Âàó
                    df_clean = df_clean.drop('ÊèêÂèñ‰ΩçÁΩÆ', axis=1)
                
                # Â∫îÁî®ÈáëÈ¢ùÊèêÂèñ
                if has_amount_column:
                    with st.spinner("Ê≠£Âú®ÊèêÂèñÈáëÈ¢ùÊï∞ÊçÆ..."):
                        df_clean['ÊäïÊ≥®ÈáëÈ¢ù'] = df_clean['ÈáëÈ¢ù'].apply(analyzer.extract_bet_amount)
                    
                    total_bet_amount = df_clean['ÊäïÊ≥®ÈáëÈ¢ù'].sum()
                    valid_amount_count = (df_clean['ÊäïÊ≥®ÈáëÈ¢ù'] > 0).sum()
                    
                    st.success(f"üí∞ ÈáëÈ¢ùÊèêÂèñÂÆåÊàê: ÊÄªÊäïÊ≥®È¢ù {total_bet_amount:,.2f} ÂÖÉ")
                    st.info(f"üìä ÊúâÊïàÈáëÈ¢ùËÆ∞ÂΩï: {valid_amount_count:,} / {len(df_clean):,}")

                # ÊòæÁ§∫Êï∞ÊçÆÈ¢ÑËßà
                with st.expander("üìä Êï∞ÊçÆÈ¢ÑËßà", expanded=False):
                    st.dataframe(df_clean.head(10))
                    st.write(f"Êï∞ÊçÆÂΩ¢Áä∂: {df_clean.shape}")
                    
                    # ÊòæÁ§∫ÂΩ©ÁßçÁ±ªÂûãÂàÜÂ∏É
                    if 'ÂΩ©ÁßçÁ±ªÂûã' in df_clean.columns:
                        st.write("üé≤ ÂΩ©ÁßçÁ±ªÂûãÂàÜÂ∏É:")
                        lottery_type_dist = df_clean['ÂΩ©ÁßçÁ±ªÂûã'].value_counts()
                        display_dist = lottery_type_dist.rename({
                            'six_mark': 'ÂÖ≠ÂêàÂΩ©',
                            '10_number': 'Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶',
                            'fast_three': 'Âø´‰∏â'
                        })
                        st.dataframe(display_dist.reset_index().rename(columns={'index': 'ÂΩ©ÁßçÁ±ªÂûã', 'ÂΩ©ÁßçÁ±ªÂûã': 'Êï∞Èáè'}))
                    
                    # ÊòæÁ§∫Áé©Ê≥ïÂàÜÂ∏É
                    if 'Áé©Ê≥ï' in df_clean.columns:
                        st.write("üéØ Áé©Ê≥ïÂàÜÂ∏É:")
                        play_dist = df_clean['Áé©Ê≥ï'].value_counts()
                        st.dataframe(play_dist.reset_index().rename(columns={'index': 'Áé©Ê≥ï', 'Áé©Ê≥ï': 'Êï∞Èáè'}))
                    
                    # ÊòæÁ§∫ÈáëÈ¢ùÂàÜÂ∏É
                    if has_amount_column:
                        st.write("üí∞ ÈáëÈ¢ùÁªüËÆ°:")
                        st.write(f"- ÊÄªÊäïÊ≥®È¢ù: {total_bet_amount:,.2f} ÂÖÉ")
                        st.write(f"- Âπ≥ÂùáÊØèÊ≥®: {df_clean['ÊäïÊ≥®ÈáëÈ¢ù'].mean():.2f} ÂÖÉ")
                        st.write(f"- ÊúÄÂ§ßÂçïÊ≥®: {df_clean['ÊäïÊ≥®ÈáëÈ¢ù'].max():.2f} ÂÖÉ")
                        st.write(f"- ÊúÄÂ∞èÂçïÊ≥®: {df_clean['ÊäïÊ≥®ÈáëÈ¢ù'].min():.2f} ÂÖÉ")

                # Á≠õÈÄâÊúâÊïàÁé©Ê≥ïÊï∞ÊçÆ
                if analysis_mode == "‰ªÖÂàÜÊûêÂÖ≠ÂêàÂΩ©":
                    valid_plays = ['ÁâπÁ†Å', 'Ê≠£Á†Å‰∏Ä', 'Ê≠£Á†Å‰∫å', 'Ê≠£Á†Å‰∏â', 'Ê≠£Á†ÅÂõõ', 'Ê≠£Á†Å‰∫î', 'Ê≠£Á†ÅÂÖ≠', 
                                 'Ê≠£‰∏ÄÁâπ', 'Ê≠£‰∫åÁâπ', 'Ê≠£‰∏âÁâπ', 'Ê≠£ÂõõÁâπ', 'Ê≠£‰∫îÁâπ', 'Ê≠£ÂÖ≠Áâπ', 'Âπ≥Á†Å', 'Âπ≥Áâπ',
                                 'Â∞æÊï∞', 'ÂÖ®Â∞æ', 'ÁâπÂ∞æ']  # üÜï Êñ∞Â¢ûÂ∞æÊï∞Áõ∏ÂÖ≥Áé©Ê≥ï
                elif analysis_mode == "‰ªÖÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶":
                    valid_plays = ['ÂÜ†ÂÜõ', '‰∫öÂÜõ', 'Â≠£ÂÜõ', 'Á¨¨ÂõõÂêç', 'Á¨¨‰∫îÂêç', 'Á¨¨ÂÖ≠Âêç', 'Á¨¨‰∏ÉÂêç', 'Á¨¨ÂÖ´Âêç', 'Á¨¨‰πùÂêç', 'Á¨¨ÂçÅÂêç', 'ÂÆö‰ΩçËÉÜ', 'Ââç‰∏Ä']
                elif analysis_mode == "‰ªÖÂàÜÊûêÂø´‰∏â":
                    valid_plays = ['ÂíåÂÄº']
                else:
                    valid_plays = ['ÁâπÁ†Å', 'Ê≠£Á†Å‰∏Ä', 'Ê≠£Á†Å‰∫å', 'Ê≠£Á†Å‰∏â', 'Ê≠£Á†ÅÂõõ', 'Ê≠£Á†Å‰∫î', 'Ê≠£Á†ÅÂÖ≠', 
                                 'Ê≠£‰∏ÄÁâπ', 'Ê≠£‰∫åÁâπ', 'Ê≠£‰∏âÁâπ', 'Ê≠£ÂõõÁâπ', 'Ê≠£‰∫îÁâπ', 'Ê≠£ÂÖ≠Áâπ', 'Âπ≥Á†Å', 'Âπ≥Áâπ',
                                 'Â∞æÊï∞', 'ÂÖ®Â∞æ', 'ÁâπÂ∞æ',  # üÜï Êñ∞Â¢ûÂ∞æÊï∞Áõ∏ÂÖ≥Áé©Ê≥ï
                                 'ÂÜ†ÂÜõ', '‰∫öÂÜõ', 'Â≠£ÂÜõ', 'Á¨¨ÂõõÂêç', 'Á¨¨‰∫îÂêç', 'Á¨¨ÂÖ≠Âêç', 'Á¨¨‰∏ÉÂêç', 'Á¨¨ÂÖ´Âêç', 'Á¨¨‰πùÂêç', 'Á¨¨ÂçÅÂêç', 'ÂÆö‰ΩçËÉÜ', 'Ââç‰∏Ä', 'ÂíåÂÄº']
                
                df_target = df_clean[df_clean['Áé©Ê≥ï'].isin(valid_plays)]
                
                # Ê†πÊçÆÂàÜÊûêÊ®°ÂºèÁ≠õÈÄâÂΩ©Áßç
                if analysis_mode == "‰ªÖÂàÜÊûêÂÖ≠ÂêàÂΩ©":
                    df_target = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == 'six_mark']
                    st.info(f"üîç Â∑≤Á≠õÈÄâÂÖ≠ÂêàÂΩ©Êï∞ÊçÆ: {len(df_target):,} Êù°ËÆ∞ÂΩï")
                elif analysis_mode == "‰ªÖÂàÜÊûêÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶":
                    df_target = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == '10_number']
                    st.info(f"üîç Â∑≤Á≠õÈÄâÊó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶Êï∞ÊçÆ: {len(df_target):,} Êù°ËÆ∞ÂΩï")
                elif analysis_mode == "‰ªÖÂàÜÊûêÂø´‰∏â":
                    df_target = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == 'fast_three']
                    st.info(f"üîç Â∑≤Á≠õÈÄâÂø´‰∏âÊï∞ÊçÆ: {len(df_target):,} Êù°ËÆ∞ÂΩï")
                else:
                    # Ëá™Âä®ËØÜÂà´Ê®°ÂºèÔºå‰øùÁïôÊâÄÊúâÊîØÊåÅÁöÑÂΩ©Áßç
                    df_target = df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'].notna()]
                    six_mark_count = len(df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == 'six_mark'])
                    ten_number_count = len(df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == '10_number'])
                    fast_three_count = len(df_target[df_target['ÂΩ©ÁßçÁ±ªÂûã'] == 'fast_three'])
                    st.info(f"üîç Ëá™Âä®ËØÜÂà´Ê®°Âºè: ÂÖ≠ÂêàÂΩ© {six_mark_count:,} Êù°ÔºåËµõËΩ¶Á±ª {ten_number_count:,} Êù°ÔºåÂø´‰∏â {fast_three_count:,} Êù°")
                
                st.write(f"‚úÖ ÊúâÊïàÁé©Ê≥ïÊï∞ÊçÆË°åÊï∞: {len(df_target):,}")

                if len(df_target) == 0:
                    st.error("‚ùå Êú™ÊâæÂà∞Á¨¶ÂêàÊù°‰ª∂ÁöÑÊúâÊïàÁé©Ê≥ïÊï∞ÊçÆ")
                    st.info("""
                    **ÂèØËÉΩÂéüÂõ†:**
                    1. ÂΩ©ÁßçÂêçÁß∞‰∏çÂåπÈÖç - ÂΩìÂâçÊîØÊåÅÁöÑÂΩ©ÁßçÁ±ªÂûã:
                       - **ÂÖ≠ÂêàÂΩ©**: Êñ∞Êæ≥Èó®ÂÖ≠ÂêàÂΩ©, Êæ≥Èó®ÂÖ≠ÂêàÂΩ©, È¶ôÊ∏ØÂÖ≠ÂêàÂΩ©Á≠â
                       - **Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶**: Êó∂Êó∂ÂΩ©, PK10, ËµõËΩ¶, Âπ∏Ëøê28Á≠â
                       - **Âø´‰∏â**: Âø´‰∏â, Âø´3, K3, ÂàÜÂàÜÂø´‰∏âÁ≠â
                    
                    2. Áé©Ê≥ïÂêçÁß∞‰∏çÂåπÈÖç - ÂΩìÂâçÊîØÊåÅÁöÑÁé©Ê≥ï:
                       - **ÂÖ≠ÂêàÂΩ©**: ÁâπÁ†Å, Ê≠£Á†Å‰∏ÄËá≥Ê≠£Á†ÅÂÖ≠, Ê≠£‰∏ÄÁâπËá≥Ê≠£ÂÖ≠Áâπ, Âπ≥Á†Å, Âπ≥Áâπ
                       - **Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶**: ÂÜ†ÂÜõ„ÄÅ‰∫öÂÜõ„ÄÅÂ≠£ÂÜõ„ÄÅÁ¨¨ÂõõÂêçÂà∞Á¨¨ÂçÅÂêç„ÄÅÂÆö‰ΩçËÉÜ„ÄÅÂâç‰∏Ä
                       - **Âø´‰∏â**: ÂíåÂÄº
                    
                    3. Êï∞ÊçÆÊ†ºÂºèÈóÆÈ¢ò
                    """)
                    return

                # ÂàÜÊûêÊï∞ÊçÆ - ‰ΩøÁî®Â¢ûÂº∫ÁâàÂàÜÊûê
                with st.spinner("Ê≠£Âú®ËøõË°åÂÆåÁæéË¶ÜÁõñÂàÜÊûê..."):
                    six_mark_params = {
                        'min_number_count': six_mark_min_number_count,
                        'min_avg_amount': six_mark_min_avg_amount
                    }
                    ten_number_params = {
                        'min_number_count': ten_number_min_number_count,
                        'min_avg_amount': ten_number_min_avg_amount
                    }
                    fast_three_params = {
                        'min_number_count': fast_three_min_number_count,
                        'min_avg_amount': fast_three_min_avg_amount
                    }
                    
                    all_period_results = analyzer.analyze_with_progress(
                        df_target, six_mark_params, ten_number_params, fast_three_params, analysis_mode
                    )

                # ÊòæÁ§∫ÁªìÊûú - ‰ΩøÁî®Â¢ûÂº∫ÁâàÂ±ïÁ§∫
                st.header("üìä ÂÆåÁæéË¶ÜÁõñÁªÑÂêàÊ£ÄÊµãÁªìÊûú")
                analyzer.display_enhanced_results(all_period_results, analysis_mode)
                
                # ÂØºÂá∫ÂäüËÉΩ
                if all_period_results:
                    st.markdown("---")
                    st.subheader("üì• Êï∞ÊçÆÂØºÂá∫")
                    
                    if st.button("üìä ÁîüÊàêÂÆåÁæéÁªÑÂêàÊï∞ÊçÆÊä•Âëä"):
                        download_df = analyzer.enhanced_export(all_period_results, analysis_mode)
                        
                        # ËΩ¨Êç¢‰∏∫Excel
                        output = BytesIO()
                        with pd.ExcelWriter(output, engine='openpyxl') as writer:
                            download_df.to_excel(writer, index=False, sheet_name='ÂÆåÁæéÁªÑÂêàÊï∞ÊçÆ')
                            
                            # Ê∑ªÂä†ÁªüËÆ°Â∑•‰ΩúË°®
                            account_stats = analyzer._calculate_detailed_account_stats(all_period_results)
                            if account_stats:
                                df_account_stats = pd.DataFrame(account_stats)
                                df_account_stats.to_excel(writer, index=False, sheet_name='Ë¥¶Êà∑ÂèÇ‰∏éÁªüËÆ°')
                        
                        # Êèê‰æõ‰∏ãËΩΩ
                        st.download_button(
                            label="üì• ‰∏ãËΩΩÂÆåÊï¥ÂàÜÊûêÊä•Âëä",
                            data=output.getvalue(),
                            file_name=f"ÂÖ®ÂΩ©ÁßçÂÆåÁæéÁªÑÂêàÂàÜÊûêÊä•Âëä_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        )
                        
                        st.success("‚úÖ Êï∞ÊçÆÂØºÂá∫ÂáÜÂ§áÂÆåÊàêÔºÅ")
                
            else:
                st.error(f"‚ùå Áº∫Â∞ëÂøÖË¶ÅÊï∞ÊçÆÂàóÔºåÂèØÁî®Âàó: {available_columns}")
                st.info("üí° ËØ∑Á°Æ‰øùÊñá‰ª∂ÂåÖÂê´‰ª•‰∏ãÂøÖË¶ÅÂàó:")
                for col in ['‰ºöÂëòË¥¶Âè∑', 'ÂΩ©Áßç', 'ÊúüÂè∑', 'Áé©Ê≥ï', 'ÂÜÖÂÆπ']:
                    st.write(f"- {col}")
        
        except Exception as e:
            st.error(f"‚ùå Â§ÑÁêÜÊñá‰ª∂Êó∂Âá∫Èîô: {str(e)}")
            logger.error(f"Êñá‰ª∂Â§ÑÁêÜÈîôËØØ: {str(e)}", exc_info=True)
            
            # Êèê‰æõÊõ¥ËØ¶ÁªÜÁöÑÈîôËØØ‰ø°ÊÅØ
            with st.expander("üîç Êü•ÁúãËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØ", expanded=False):
                st.code(f"""
        ÈîôËØØÁ±ªÂûã: {type(e).__name__}
        ÈîôËØØ‰ø°ÊÅØ: {str(e)}
                
        ÂèØËÉΩÁöÑÂéüÂõ†:
        1. Êñá‰ª∂ÁºñÁ†ÅÈóÆÈ¢ò - Â∞ùËØïÂ∞ÜÊñá‰ª∂Âè¶Â≠ò‰∏∫UTF-8ÁºñÁ†Å
        2. Êñá‰ª∂Ê†ºÂºèÈóÆÈ¢ò - Á°Æ‰øùÊñá‰ª∂ÊòØÊúâÊïàÁöÑCSVÊàñExcelÊ†ºÂºè
        3. ÂÜÖÂ≠ò‰∏çË∂≥ - Â∞ùËØïÂàÜÊûêËæÉÂ∞èÁöÑÊï∞ÊçÆÊñá‰ª∂
        4. ÂàóÂêç‰∏çÂåπÈÖç - Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶ÂåÖÂê´ÂøÖË¶ÅÁöÑÂàó
                
        Â¶ÇÊûúÈóÆÈ¢òÊåÅÁª≠Â≠òÂú®ÔºåËØ∑ËÅîÁ≥ªÊäÄÊúØÊîØÊåÅ„ÄÇ
                """)
    
    else:
        st.info("üí° **ÂΩ©Á•®ÂÆåÁæéË¶ÜÁõñÂàÜÊûêÁ≥ªÁªü**")
        st.markdown("""
        ### üöÄ Á≥ªÁªüÁâπËâ≤ÂäüËÉΩ:

        **üé≤ ÂÖ®ÂΩ©ÁßçÊîØÊåÅ**
        - ‚úÖ **ÂÖ≠ÂêàÂΩ©**: 1-49‰∏™Âè∑Á†ÅÔºåÊîØÊåÅÁâπÁ†Å„ÄÅÊ≠£Á†Å„ÄÅÊ≠£Áâπ„ÄÅÂπ≥Á†ÅÁ≠âÂ§öÁßçÁé©Ê≥ï
        - ‚úÖ **Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶**: 1-10ÂÖ±10‰∏™Âè∑Á†ÅÔºå**Êåâ‰ΩçÁΩÆÁ≤æÂáÜÂàÜÊûê**  
        - ‚úÖ **Âø´‰∏â**: 3-18ÂÖ±16‰∏™Âè∑Á†ÅÔºåÂíåÂÄºÁé©Ê≥ï
        - üîÑ **Ëá™Âä®ËØÜÂà´**: Êô∫ËÉΩËØÜÂà´ÂΩ©ÁßçÁ±ªÂûã

        **üìç ‰ΩçÁΩÆÁ≤æÂáÜÂàÜÊûê**
        - ‚úÖ **ÂÖ≠ÂêàÂΩ©‰ΩçÁΩÆ**: ÁâπÁ†Å„ÄÅÊ≠£Á†Å‰∏ÄËá≥Ê≠£Á†ÅÂÖ≠„ÄÅÊ≠£‰∏ÄÁâπËá≥Ê≠£ÂÖ≠Áâπ„ÄÅÂπ≥Á†Å„ÄÅÂπ≥Áâπ
        - ‚úÖ **PK10/ËµõËΩ¶‰ΩçÁΩÆ**: ÂÜ†ÂÜõ„ÄÅ‰∫öÂÜõ„ÄÅÂ≠£ÂÜõ„ÄÅÁ¨¨ÂõõÂêçÂà∞Á¨¨ÂçÅÂêç„ÄÅÂâç‰∏Ä
        - ‚úÖ **Âø´‰∏â‰ΩçÁΩÆ**: ÂíåÂÄº
        - ‚úÖ **‰ΩçÁΩÆÁªüËÆ°**: Êåâ‰ΩçÁΩÆÁªüËÆ°ÂÆåÁæéÁªÑÂêàÊï∞Èáè

        **üîç Êô∫ËÉΩÊï∞ÊçÆËØÜÂà´**
        - ‚úÖ Â¢ûÂº∫ÂàóÂêçËØÜÂà´ÔºöÊîØÊåÅÂ§öÁßçÂàóÂêçÂèò‰Ωì
        - üìä Êï∞ÊçÆË¥®ÈáèÈ™åËØÅÔºöÂÆåÊï¥ÁöÑÊï∞ÊçÆÊ£ÄÊü•ÊµÅÁ®ã
        - üéØ Áé©Ê≥ïÂàÜÁ±ªÁªü‰∏ÄÔºöÊô∫ËÉΩËØÜÂà´ÂêÑÂΩ©ÁßçÁé©Ê≥ï
        - üí∞ ÈáëÈ¢ùÊèêÂèñ‰ºòÂåñÔºöÊîØÊåÅÂ§öÁßçÈáëÈ¢ùÊ†ºÂºè

        **‚ö° ÊÄßËÉΩ‰ºòÂåñ**
        - üîÑ ÁºìÂ≠òÊú∫Âà∂ÔºöÂè∑Á†ÅÂíåÈáëÈ¢ùÊèêÂèñÁºìÂ≠ò
        - üìà ËøõÂ∫¶ÊòæÁ§∫ÔºöÂÆûÊó∂ÂàÜÊûêËøõÂ∫¶
        - üé® ÁïåÈù¢‰ºòÂåñÔºöÁé∞‰ª£ÂåñStreamlitÁïåÈù¢

        **üìä ÂàÜÊûêÂ¢ûÂº∫**
        - üë• Ë¥¶Êà∑ËÅöÂêàËßÜÂõæÔºöÊåâË¥¶Êà∑ÁªüËÆ°ÂèÇ‰∏éÊÉÖÂÜµÂíåÊÄªÊäïÊ≥®ÈáëÈ¢ù
        - üìã ËØ¶ÁªÜÁªÑÂêàÂàÜÊûêÔºöÂÆåÊï¥ÁöÑÁªÑÂêà‰ø°ÊÅØÂ±ïÁ§∫
        - üìä Ê±áÊÄªÁªüËÆ°ÔºöÂ§öÁª¥Â∫¶Êï∞ÊçÆÁªüËÆ°

        ### üéØ ÂêÑÂΩ©ÁßçÂàÜÊûêÂéüÁêÜ:

        **ÂÖ≠ÂêàÂΩ© (49‰∏™Âè∑Á†Å)**
        - Ê£ÄÊµãÂêå‰∏ÄÊúüÂè∑„ÄÅÂêå‰∏Ä‰ΩçÁΩÆÂÜÖ‰∏çÂêåË¥¶Êà∑ÁöÑÊäïÊ≥®Âè∑Á†ÅÊòØÂê¶ÂΩ¢ÊàêÂÆåÁæéË¶ÜÁõñÔºà1-49ÂÖ®ÈÉ®Ë¶ÜÁõñÔºâ
        - ÂàÜÊûêÂêÑË¥¶Êà∑ÁöÑÊäïÊ≥®ÈáëÈ¢ùÂåπÈÖçÂ∫¶ÔºåËØÜÂà´ÂèØÁñëÁöÑÂçèÂêåÊäïÊ≥®Ë°å‰∏∫
        - ÊîØÊåÅÁâπÁ†Å„ÄÅÊ≠£Á†Å„ÄÅÊ≠£Áâπ„ÄÅÂπ≥Á†ÅÁ≠âÂ§öÁßçÁé©Ê≥ï

        **Êó∂Êó∂ÂΩ©/PK10/ËµõËΩ¶ (10‰∏™Âè∑Á†Å)**  
        - **Êåâ‰ΩçÁΩÆÁ≤æÂáÜÂàÜÊûê**: ÂÜ†ÂÜõ„ÄÅ‰∫öÂÜõ„ÄÅÂ≠£ÂÜõÁ≠âÊØè‰∏™‰ΩçÁΩÆÁã¨Á´ãÂàÜÊûê
        - Ê£ÄÊµãÂêå‰∏Ä‰ΩçÁΩÆÂÜÖÔºå‰∏çÂêåË¥¶Êà∑ÊòØÂê¶Ë¶ÜÁõñÂÖ®ÈÉ®10‰∏™Âè∑Á†ÅÔºà1-10Ôºâ
        - ËØÜÂà´ÂØπÂà∑Ë°å‰∏∫ÔºöÂ§ö‰∏™Ë¥¶Êà∑Âú®Âêå‰∏Ä‰ΩçÁΩÆÂêà‰ΩúË¶ÜÁõñÊâÄÊúâÂè∑Á†Å

        **Âø´‰∏â (16‰∏™Âè∑Á†Å)**
        - **ÂíåÂÄºÁé©Ê≥ï**: Ê£ÄÊµãÂêå‰∏ÄÊúüÂè∑ÂÜÖ‰∏çÂêåË¥¶Êà∑ÊòØÂê¶Ë¶ÜÁõñÂÖ®ÈÉ®16‰∏™ÂíåÂÄºÔºà3-18Ôºâ
        - ÂàÜÊûêÂêÑË¥¶Êà∑ÁöÑÊäïÊ≥®ÈáëÈ¢ùÂåπÈÖçÂ∫¶ÔºåËØÜÂà´ÂèØÁñëÁöÑÂçèÂêåÊäïÊ≥®Ë°å‰∏∫

        ### üìù ÊîØÊåÅÁöÑÂàóÂêçÊ†ºÂºè:
        """)
        
        for standard_col, possible_names in analyzer.column_mappings.items():
            st.write(f"- **{standard_col}**: {', '.join(possible_names[:3])}{'...' if len(possible_names) > 3 else ''}")
        
        st.markdown("""
        ### üéØ Êï∞ÊçÆË¶ÅÊ±Ç:
        - ‚úÖ ÂøÖÈ°ªÂåÖÂê´: ‰ºöÂëòË¥¶Âè∑, ÂΩ©Áßç, ÊúüÂè∑, Áé©Ê≥ï, ÂÜÖÂÆπ
        - ‚úÖ Áé©Ê≥ïÂøÖÈ°ª‰∏∫ÊîØÊåÅÁöÑÁ±ªÂûã
        - ‚úÖ ÂΩ©ÁßçÂøÖÈ°ªÊòØÊîØÊåÅÁöÑÂΩ©Á•®Á±ªÂûã
        - üí∞ ÂèØÈÄâÂåÖÂê´ÈáëÈ¢ùÂàóËøõË°åÊ∑±Â∫¶ÂàÜÊûê
        """)

if __name__ == "__main__":
    main()
